\chapter{Background \& Related Work}
\label{ch:background}

% This section is where you will discuss relevant background work, and related works for comparison.
% Ensure that you cite references appropriately, using this as an example~\citep{sample2019}
%
% \section{Background Topic 1}
%
% \section{Background Topic 2}
%
% \section{Related Work}

\section{Intelligent Agents}
\label{sec:agents}

There has been prior research and discussion to determine what constitutes an \textit{agent}.
Though work by \citet{wooldridge_agent_1995} fails to completely define the term,
the authors do propose a set of characteristics that agents must have.
They are summarized by \citet{dignum_intentional_1998} and are as follows.

First, the agent must have autonomy to complete its own actions without the intervention of a human.
This implies that it is making decisions on its own power.
Second, the choices of an agent must be best explained in terms of some form of \textit{intention}.
These intentions can be desires, goals, etc.
An implication of this requirement is that agents cannot be explained through low-level concepts.
Lastly, an agent explained with particular intentions should seem to actually progress their satisfaction.
At the very least, an agent should be \textit{trying} to fulfill its intentions (even if it is doing so poorly).
A system that does not even do this cannot be called an \textit{agent}.

There are many different kinds of agents.
\citet{balke_how_2014} provide a survey of five different kinds of agents.

The first of these are \textit{production rule systems}~\citep{balke_how_2014}.
Production rule systems are symbolic in nature and
consist of three core components:

\begin{itemize}

    \item A set of \textit{rules} (also called \textit{productions}).
        Each rule has the form $ C_i \rightarrow A_i $,
        where $ C_i $ is what is called the \textit{sensory precondition}
        and $ A_i $ is the action to be performed if $ C_i $ is true.
        $ C_i $ is essentially an \textit{if} condition and $ A_i $ is the conditionally executed body.

    \item A knowledge base that stores domain-relevant information about the agent's environment.
        This is called the \textit{working memory}.

    \item A \textit{rule interpreter} that determines which rules apply for the current state of the working memory.
        In the case of rule conflicts, it decides which rule should be executed.

\end{itemize}

% TODO: Consider talking about architecture

Production rule systems are usually implemented in Prolog or Lisp~\citep{balke_how_2014}.

The next class of agents are those ascribing to the \textit{BDI Architecture}~\citep{balke_how_2014}.
The belief-desire-intention (BDI) model combines a philosophical model of human practical reasoning
with several successful applications~\citep{georgeff_belief-desire-intention_1999}.
BDI agents are built on the idea of mental states,
consisting of three items: beliefs, desires, and intentions~\citep{balke_how_2014}.
\textit{Beliefs} refer to an agent's representation of the world.
An agent believes something to be true if and only if the statement is found in its representation of the world.
It is worth noting that an agent's beliefs can be inconsistent with its environment (i.e.~the agent can mistakenly believe a falsehood about its environment).

A BDI agent's \textit{desires} are all possible courses of action that it might want to accomplish in order to reach a goal~\citep{balke_how_2014}.
An agent is not necessarily committed to its desires.
They just play a part in its decision process.
\textit{Intentions}, on the other hand, are commitments to particular courses of action to reach a goal.
Courses of action are also called \textit{plans}.

In addition, BDI agents have a library of plans.
This library consists of pre-computed primitive logic rules to signify which actions contribute to accomplishing which goals.
At each reasoning step, BDI agents search through the plan library to see which plans have a post-condition that matches the currently selected intention
and then sorts them according to relevance.

The third class of agents are those that conform to \textit{normative models}.
They differ from BDI agents in that they are \textit{externally motivated}.
BDI agents are \textit{internally motivated} since all major components (beliefs, goals, and intentions) are internal to the agent.
Normative agents are governed by norms, which are imposed by the agent's external environment.

The last two classes of agents are those with cognitive models~\citep{balke_how_2014}.
They can be divided into those that have \textit{simple} cognitive models and those that have \textit{cognitive architectures}.
The simple cognitive models share similarities with the agent classes presented above
whereas the cognitive architectures are heavily influenced by the structure of the human brain.

\section{Evaluation of Agent Architectures}
\label{sec:agent_evaluation}

Given these five classes of agent architectures, one needs a way of objectively comparing them.
\citet{balke_how_2014} provide five different dimensions on which these architectures can be evaluated.

The first one is the \textit{cognitive dimension}.
This dimension considers what kind of reasoning is able to be performed by an agent.
\citeauthor{balke_how_2014} evaluate architectures on whether agents are \textit{reactive} or \textit{deliberative}.
Reactive agents are those that only respond to stimuli in their environment and typically follow rule-based patterns.
Deliberative agents, on the other hand, actively consider different courses of action and weigh the utility of each.
For example, production rule systems are an example of reactive agents whereas BDI agents are deliberative~\citep{balke_how_2014}.

The second dimension for agent architecture comparisons is the \textit{affective dimension}~\citep{balke_how_2014}.
The affective dimension considers what degree of emotions agents in an architecture are capable of expressing and acting upon.
Research towards this dimension considers how emotions can be triggered, how they influence the decision process, and how changes in decisions affect the system at large.
Most models are incapable of acting upon emotions~\citep{balke_how_2014} with the exception of two extensions of the BDI model~\citep{jiang_ebdi_2007, dignum_towards_2009} and a cognitive model~\citep{urban_pecs_2000}.

A third dimension for comparing architectures is the \textit{social dimension}.
This dimension considers the extent to which agent architectures provide agents the ability to communicate with other agents, to distinguish social relations (such as status), and to understand complex social concepts.
All the normative models discussed by \citet{balke_how_2014}, along with a few others among BDI extensions and cognitive models, have a notion of self, others, and groups.
BDI agents, in the original model, as well as production rule systems have no notion of social concepts or communication.

Fourth, agent architectures can be evaluated according to the extent of formal and social norms that agents can reason over~\citep{balke_how_2014}.

Lastly, architectures can be compared by considering the type of agent learning that the architecture enables for its agents~\citep{balke_how_2014}.
This dimension considers whether agents can improve or expand their knowledge base given environmental observations.
If agents are capable of doing this, it also considers in what ways the knowledge base can be extended (e.g.~whether they adjust the values for pre-existing decision functions or create new decision rules from scratch)~\citep{balke_how_2014}.
Production rule systems and BDI agents (including its variants) do not support any form of learning whereas normative and cognitive model support it to various extents.

A related consideration for agent architectures is its \textit{elaboration tolerance}.
Elaboration tolerance measures the ease of which a knowledge base can be changed to incorporate new facts~\citep{parmar_formalizing_2003}, whether by learning or by a human redesign.
For example, a representation with a high elaboration tolerance might require very little changes to represent additional information whereas a representation with a low elaboration tolerance may need to be completely re-written to address a new scenario.
The concept was first mentioned by \citet{mccarthy_mathematical_1988}, but later formalized by \citet{parmar_formalizing_2003}.

\section{Logic-based Intelligent Agents}
\label{sec:logic_based_agents}

In addition to those mentioned by \citet{balke_how_2014}, there has been research on various logic-based agent architectures.
These agent architectures are based off the notion of an \textit{action language} which, in turn, are based on \textit{transition systems}.

\subsection{Transition Systems}
\label{subsec:transition_systems}

Transition systems (also called \textit{transition diagrams}~\citep{blount_architecture_2013}) can be thought of as analogous to a directed graph that models a discrete dynamic domain.
Discrete dynamic domains are environments that behave according to the following rules~\citep{blount_architecture_2013}:

\begin{itemize}
    \item The environment updates in discrete time steps.
    \item Actions occur instantaneously at each time step and the effects appear immediately at the next time step.
    \item Each domain-relevant property is represented by a function.
        The function maps the property name, called a \textit{fluent}, to its value at a particular time step.
        Fluents with their values are collectively referred to as the agent's \textit{state}.
\end{itemize}

Transition systems, then, are akin to directed graphs where the vertices are possible states of the world and edges are actions that, when performed, transition the world from one state to another.
Their formal definition is as follows:

\begin{definition}
    \label{def:action_signature}
    An action signature $ < \boldsymbol{V}, \boldsymbol{F}, \boldsymbol{A}> $ consists of three sets: a set $ \boldsymbol{V} $ for value names, a set $ \boldsymbol{F} $ of fluent names, and a set $ \boldsymbol{A} $ of action names~\citep{gelfond_action_1998}.
\end{definition}

\begin{definition}
    \label{def:propositional_action_signature}
    An action signature $< \boldsymbol{V}, \boldsymbol{F}, \boldsymbol{A}>$ is \textit{propositional} if $\boldsymbol{V}=\{t,f\}$~\citep{gelfond_action_1998}.
\end{definition}

\begin{definition}
    \label{def:transition_system}
    A transition system of an action signature $ < \boldsymbol{V}, \boldsymbol{F}, \boldsymbol{A}> $ consists of a set $ S $ of states, a function $ V : \boldsymbol{F} \times S\rightarrow \boldsymbol{V} $, and a set of transitions $ R \subseteq S \times \mathcal{P}(\boldsymbol{A}) \times S $.
\end{definition}

$ V(P,s) $ is said to be the value of fluent $ P $ in state $ s $.
The states $ s' $ such that $ <s, A, s'> \in R $ are the possible results of an action $ A $'s execution in state $ s $.

\begin{definition}
    \label{def:action_a_determinism}
    Action $ A $ is \textit{deterministic} in state $ s $ if there is exactly one state $ s' $~\citep{gelfond_action_1998}.
    If $ A $ is \textit{non-deterministic}, then each state $ s' $ \textit{may} be the result of action $ A $~\citep{blount_architecture_2013}.
    $ A $ is \textit{executable} in $ s $ iff there is at least one state $ s' $ where $ <s, A, s'> \in R $.
    When $ \left|A\right|>1 $, $A$ represents the execution of concurrent actions~\citep{gelfond_action_1998, blount_architecture_2013}.
\end{definition}

\begin{definition}
    \label{def:wait}
    When action $A = \emptyset$, $A$ is sometimes denoted as $Wait$~\citep{gelfond_action_1998}.
\end{definition}

\begin{definition}
    \label{def:event}
    The pair $<s, A>$ is sometimes called an \textit{event}~\citep{gelfond_authorization_2008}.
\end{definition}

\begin{definition}
    \label{def:trajectory}
    A path $ <s_0, A_0, s_1, A_1, \dots, A_{\left\{n-1\right\}}, s_n> $ represents a possible \textit{trajectory} of a system with the initial state $ s_0 $ and final state $ s_n $~\citep{blount_architecture_2013}.
\end{definition}

\begin{definition}
    \label{def:propositional_transition_system}
    If the action signature of a transition system is propositional, then the transition system is said to be \textit{propositional}~\citep{gelfond_action_1998}.
\end{definition}

\begin{definition}
    Fluents of a propositional action signature are sometimes referred to as \textit{boolean fluents}.
    Otherwise, there are called \textit{functional fluents}~\citep{chintabathina_modeling_2004}.
\end{definition}

\begin{definition}
    An action $a \in A$ is sometimes called an \textit{elementary action} where $A$ is called a \textit{compound action}~\citep{gelfond_authorization_2008}.
\end{definition}

\subsection{Action Languages}
\label{subsec:action_languages}

While transition systems are useful because of their strong mathematical foundation, specifying complex transition systems is very difficult in practice.
To remedy this, helpful abstractions of transitions systems called \textit{action languages} have been proposed.
Action languages are formal models that describe the effects of actions in a concise format~\citep{gelfond_action_1998}.
There are two kinds of action languages: action description languages and action query languages.
Action description languages describe action effects in terms of a transition system and action query languages state assertions about a transition system~\citep{gelfond_action_1998}.
We will focus only on action description languages and will use the term \textit{action languages} to refer to them.

Many action languages exist, including $ \mathcal{A} $~\citep{gelfond_action_1998}, $ \mathcal{B} $~\citep{gelfond_action_1998}, $ \mathcal{C} $~\citep{gelfond_action_1998}, $ \mathcal{AC} $~\citep{turner_representing_1997}, $ \mathcal{AL} $~\citep{baral_reasoning_2000}, $ \mathcal{ALM} $~\citep{inclezan_modular_2016}.

\subsubsection{Action Language $ \mathcal{A} $}
\label{subsubsec:action_language_a}

First, we will discuss action language $ \mathcal{A} $.
Action language $ \mathcal{A} $ was first proposed by \citet{pednault_formulating_1987}.
$ \mathcal{A} $ models a transition system with the signature $ <\{t, f\}, \boldsymbol{F}, \boldsymbol{A}> $.
It is composed of propositions of the form:
\begin{equation}
    a \textbf{ causes } L \textbf{ if } F
\end{equation}
where $ a \in \boldsymbol{A} $ is an action name, $ L $ is a literal (also known as the head), and $ F \subseteq(\boldsymbol{F} \cup\{\neg f | f \in \boldsymbol{F}\}) $ is a possibly empty conjunction of literals~\citep{gelfond_action_1998}.
A literal is an element of $(\boldsymbol{F} \cup \{\neg f | f \in \boldsymbol{F}\})$.
Since we model a propositional transition system, $L$ denotes $V(L, s') = t$ for a transition from $s$ to $s'$ where $F$ holds in $s$ and $a$ occurs.
Likewise, $\neg L$ denotes $V(L, s')=f$.
In the case $ F $ is empty, it is denoted as $ True $ and can be omitted (along with the preceding ``if'').
A set of these propositions is called an \textit{action description}~\citep{gelfond_action_1998}.

To formally define the semantics of an action description in $\mathcal{A}$, we need to first define an interpretation.

\begin{definition}
    \label{def:interpretation}
    A function $G$ is an \textit{interpretation} of a set $S$ iff $G: S \rightarrow \{t, f\}$~\citep{gelfond_action_1998}.
\end{definition}

\begin{definition}
    Let $ D $ be an action description in $ \mathcal{A} $.
    The transition system $ <S, V, R> $ described by $ D $ is defined as follows~\citep{gelfond_action_1998}:

    \begin{itemize}
        \item $ S $ is the set of all interpretations of $ \boldsymbol{F} $.
        \item $ V(P, s) $ is the value of fluent $P$ in state $s$.
        \item R is the set of all triples $ <s, \{a\}, s'> $ such that $ E(a,s) \subseteq s' \subseteq E(a,s) \cup s $.
    \end{itemize}
    where $ E(a, s) $ is the set of heads $ L $ of all propositions $ a \textbf{ causes } L \textbf{ if } F $ in $ D $ such that $ s $ satisfies $ F $.
    $ E(a, s) $ represents all effects of an action $ a $ in state $ s $~\citep{gelfond_action_1998}.
    Writing $ E\left(a,s\right)\subseteq s' $ constrains $ s' $ such that it must represent states in which the effects of $ a $ are actually present.
    Adding $ \subseteq E\left(a,s\right)\cup s $, allows $ s' $ to equal $ s $.
    It is worth noting that there can only be at most one $ s' $ satisfying the above equation~\citep{gelfond_action_1998}.
    Therefore, $ a $ is deterministic for every state.
\end{definition}

Suppose we had the following action description in $\mathcal{A}$, as given by \citet{gelfond_action_1998}:
\begin{equation}
    \label{eq:action_language_a_example}
    a \textbf{ causes } P \textbf{ if } Q
\end{equation}
In this case, the action description language models the transition system shown in \cref{fig:action_language_a_example}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Figures/Action_Language_A/Example-dot}
    \caption{Transition system corresponding to \cref{eq:action_language_a_example}}
    \label{fig:action_language_a_example}
\end{figure}

\subsubsection{Action Language $ \mathcal{B} $}
\label{subsubsec:action_language_b}

Action language $ \mathcal{B} $ is an extension of action language $ \mathcal{A} $ [12] that allows the description of actions with indirect effects~\citep{gelfond_action_1998}.
It does so with the addition of so-called \textit{static laws}~\citep{gelfond_action_1998}.
\citet{gelfond_action_1998} contrast static laws to \textit{dynamic laws}, which refer to action descriptions in $\mathcal{A}$.

Like $\mathcal{A}$, $\mathcal{B}$ models a transition system with the signature $<\{t, f\},\boldsymbol{F},\boldsymbol{A}>$.
An action description in $\mathcal{B}$ is a set of static and dynamic laws, which are as follows~\citep{gelfond_action_1998}:

\begin{itemize}
    \item A static law is written in the following form:
        \begin{equation}
            L \textbf{ if } F
        \end{equation}

    \item A dynamic law, like in $\mathcal{A}$, is written in the form:
        \begin{equation}
            a \textbf{ causes } L \textbf{ if } F
        \end{equation}
\end{itemize}

\noindent
where $a \in \boldsymbol{A}$ is the action name, $L \in(\boldsymbol{F} \cup\{\neg f | f \in \boldsymbol{F}\})$ is a literal (or \textit{head}) and $F \subseteq(\boldsymbol{F} \cup\{\neg f | f \in \boldsymbol{F}\})$ is a, possibly empty, conjunction of literals.

Similar to $\mathcal{A}$, if $F$ is empty then it is denoted as $True$ and can be omitted.

$\mathcal{B}$ defines a notion of closure for sets of literals.

\begin{definition}
    \label{def:causation}
    In a dynamic law $a \textbf{ causes } L$, $a$ is said to \textit{cause} $L$.
    Adding a static law $L' \textbf{ if } L$, $a$ is said to \textit{indirectly cause} $L'$.
\end{definition}

\begin{definition}
    ``A set $s$ of literals is \textit{closed} under a set $Z$ of static laws if $s$ includes the head $L$ of every static law $L \textbf{ if } F$ in $Z$ such that $s$ satisfies $F$''~\citep{gelfond_action_1998}.
    Informally, a set $s$ of literals is closed under a set of static laws $Z$ if there are relevant static laws in $Z$ that require every literal in $s$.
    A static law is informally relevant if its set of literals $F$ is satisfied.
\end{definition}

\begin{definition}
    ``The set $C_{n_Z}\left(s\right)$ of \textit{consequences} of [a set] $s$ [of literals] under [a set] $Z$ [of static laws] is the smallest set of literals that contains $s$ and is closed under $Z$.~\citep{gelfond_action_1998}''
    Informally, the consequences of s are the collection of all effects of a particular fluent value (both direct and indirect).
\end{definition}

\begin{definition}
    Let $D$ be an action description in $\mathcal{B}$.
    The transition system $< S, V, R >$ described by $D$ is defined as follows~\citep{gelfond_action_1998}:

    \begin{itemize}
        \item $S$ is the set of all interpretations of $\boldsymbol{F}$ that are closed under the static laws of $D$.
        \item $ V(P, s) $ is the value of fluent $P$ in state $s$.
        \item $R$ is the set of all triples $<s, \{a\}, s'>$ such that
            \begin{equation}
                s'=C_{n_Z}\left(E\left(a,s\right)\cup\left(s \cap s'\right)\right)
            \end{equation}
            $ Z $ is the set of all static laws of $D$ and $E(a, s)$, as before, is the set of heads $L$ of all propositions $a \textbf{ causes } L \textbf{ if } F$ in $D$ such that $s$ satisfies $F$.
    \end{itemize}
\end{definition}

\subsubsection{Action Language $ \mathcal{AL} $}
\label{subsubsec:action_language_al}

$ \mathcal{AL} $ is based on $ \mathcal{A} $ and $ \mathcal{B} $.
It extends these languages with what authors later refer to as \textit{defined fluents}.
These are domain-relevant properties under the closed world assumption~\citep{blount_architecture_2013}.
The closed world assumption states that which cannot be proven true must be false~\citep{reiter_closed_1981}.
It contrasts from the open world assumption, which states only that which is proven is true~\citep{reiter_closed_1981}.

An action description in $ \mathcal{AL} $ is a set of propositions written in the form~\citep{baral_reasoning_2000, blount_architecture_2013}:

\begin{itemize}
    \item Dynamic laws (from Action language $ \mathcal{A} $):
        \begin{equation}
            a \textbf{ causes } L \textbf{ if } F
        \end{equation}

    \item Static laws (from Action language $ \mathcal{B} $):
        \begin{equation}
            L \textbf{ if } F
        \end{equation}

    \item Executability constraints:
        \begin{equation}
            \textbf{ impossible } a_0, a_1, \dots, a_k \textbf{ if } F
        \end{equation}
\end{itemize}

Like in $\mathcal{A}$ and $\mathcal{B}$, $a \in \boldsymbol{A}$ is the action name, $L \in(\boldsymbol{F} \cup\{\neg f | f \in \boldsymbol{F}\}) $ is a literal (or \textit{head}) and $F \subseteq(\boldsymbol{F} \cup\{\neg f | f \in \boldsymbol{F}\})$ is a possibly empty conjunction of literals.

Later work by \citet{gelfond_knowledge_2014} proposes classifications for literals: \textit{statics}, \textit{inertial fluents}, and \textit{defined fluents}.
The term \textit{fluent} has a slightly different meaning in this context.
\citet{gelfond_knowledge_2014} use the term \textit{domain property} to refer to the \textit{fluent names} introduced in our discussion of action signatures.
By \textit{fluent}, \citet{gelfond_knowledge_2014} mean the domain properties that might actually change between states.
They call domain properties that will not change between states \textit{statics}.
It is worth noting that the distinction between these fluents and statics is only useful when considering the implementation of a system using action language $\mathcal{AL}$.
Representing statics as a runtime constant can result in performance improvements.

\citet{gelfond_knowledge_2014} further partition the term \textit{fluent} into \textit{defined fluents} and \textit{inertial fluents}.
Inertial fluents are inspired by the law of inertia in that their value persists from state to state unless an action explicitly changes it (either directly or indirectly).
Defined fluents, on the other hand, are defined in terms of other fluents and do not necessarily persist from state to state.
Due to the constraints on their definition, they cannot be directly caused by an action.


\subsection{The AAA Architecture}
\label{subsec:aaa_architecture}

The first logic-based agent architecture that we will discuss is the \textit{Autonomous Agent Architecture} (AAA) architecture~\citep{balduccini_aaa_2008}.
The AAA architecture is based on work by Gelfond and collaborators~\citep{baral_reasoning_2000,balduccini_diagnostic_2003, balduccini_answer_2006,balduccini_learning_2007}.
As it is a logic-based approach, it makes certain assumptions about the environment in which an agent constructed in its architecture will be operating.
They must be met in order for the architecture to be applicable.
The assumptions are as follows~\citep{balduccini_aaa_2008}:

\begin{itemize}
    \item The world (the agent along with its environment) can be modeled in a transition system.
    \item The agent is competent in interacting with its environment (e.g.~the agent is capable of making correct observations, remembering them, and can perform actions).
    \item Normally, the agent can observe all relevant exogenous events (i.e.~events that are not an effect of an action the agent performed).
\end{itemize}

Given that these assumptions are met, an agent in the AAA architecture performs the following loop once for every time step of the environment~\citep{balduccini_aaa_2008}:

\begin{enumerate}
    \item Observe the world, explain observations, and update knowledge base.
    \item Select an appropriate goal $G$.
    \item Find a sequence of compound actions (called a \textit{plan}) that achieve $G$.
    \item Execute first action in plan and update knowledge base.
    \item Repeat (i.e.~go to step 1).
\end{enumerate}

This loop is known as the \textit{Observe-Think-Act} loop~\citep{balduccini_aaa_2008}.

In step 1, the agent observes the world and updates its knowledge base.
This knowledge base is encoded in the Answer Set Prolog (ASP) language, which allows for the representation of many different forms of knowledge [18] (ASP will be discussed later in \cref{subsubsec:asp}).
The agent stores the current state of the environment in this knowledge base as well as a history of previous observations and actions (more will be mentioned in \cref{subsubsec:domain_history})~\citep{balduccini_aaa_2008}.

There are two approaches to describing the effects of an agent's actions.
The first is to use action languages to formally denote the action effects, then to translate them into ASP for executability.
The second is to author them directly in ASP.
\citet{balduccini_aaa_2008} choose to do the latter.

It is worth noting that the agent makes no commitment to plans it found in previous loop iterations.
Each loop iteration searches for a plan irrespective to the plan that was partially executed in the previous iteration.
This makes the Observe-Think-Act loop somewhat greedy in that it chooses the best plan as can be foreseen at every time step.
In more recent work~\citep{blount_towards_2014}, \citeauthor{blount_towards_2014} see this as a limitation and build the $\mathcal{AIA}$ architecture to address it.

\subsection{The $\mathcal{AIA}$ Architecture}
\label{subsec:aia_architecture}

As stated above, the \textit{Architecture for Intentional Agents} ($\mathcal{AIA}$) is an agent architecture that borrows significantly from the AAA architecture~\citep{blount_towards_2014}.
It extends the AAA architecture by representing the possibility for action failure.
In contrast to the AAA architecture, the agent \textit{attempts} to perform an action during its control loop but may find that it is unable to do so.
In this case, the action is \textit{non-executable}~\citep{blount_towards_2014}.

The $\mathcal{AIA}$ architecture shares a number of similar assumptions with the AAA architecture~\citep{blount_towards_2014}:

\begin{itemize}
    \item The agent is capable of making correct observations.
    \item When the agent attempts to perform an action, the action occurs only when it is executable.
        Otherwise, nothing happens.
    \item The agent remembers its observations of the environment (as well as its prior attempts to take actions).
    \item Normally, the agent observes all relevant exogenous events.
\end{itemize}

However, a few assumptions differ from the AAA architecture:

\begin{itemize}
    \item The agent selects a single goal only when it does not have one and focuses on achieving it.
    \item The world must be modeled in an \textit{intentional system description} of $\mathcal{AL}$.
\end{itemize}

\subsubsection{Intentional System Description of $\mathcal{AL}$}
\label{subsubsec:intentional_action_language_al}

An intentional system description of $ \mathcal{AL} $ is an extension of $ \mathcal{AL} $ proposed by \citet{blount_architecture_2013}.
This extension is created to address the limitations of the AAA architecture, in which plans are not persisted across iterations of the Observe-Think-Act loop.
In order to persist them, plans are pre-computed and stored as a set of statics.
In the intentional system description of $\mathcal{AL}$, these pre-computed plans are encapsulated in a construct called an \textit{activity}.
Activities are the set of the following statics~\citep{blount_architecture_2013, blount_towards_2014}:

\begin{gather}
    activity(M). \\
    component(M, 1, C_1). \\
    component(M, 2, C_2). \\
    \dots \\
    component(M, L, C_L). \\
    length(M, L). \\
    goal(M, G).
\end{gather}

\noindent
where $M$ is a unique identifier for the activity, $C_1, C_2, \dots, C_L$ are the \nth{1}, \nth{2}, \dots, L\textsuperscript{th} \textit{component} of the activity, and $G$ is the goal that $C_1,C_2,\dots,C_L$ achieves.
In contrast to the AAA architecture, a component $C_k$ can either refer to an action or another activity $M'$ by its unique identifier.
In the latter case, $M'$ is a \textit{child activity} of $M$.
An activity cannot be a child (or descendant) of itself (i.e.~activities must be acyclic).
It is also worth noting that activities permit the execution of actions concurrently.

Since activities are pre-computed, there can be an exponentially large amount of unique activities represented by statics.
This can be detrimental to running an implementation so to avoid this, \citet{blount_architecture_2013} only represents activities that are deemed initially relevant and generates the rest on demand.

The intentional system description of $\mathcal{AL}$ uses fluents to keep track of the agent's progress in the current activity.
These fluents define the agent's \textit{mental state} and are updated through \textit{mental actions}.
Mental actions contrast from \textit{physical actions} in that mental actions only affect the internal state of the agent whereas physical actions affect the agent's environment.
The effects of mental actions are defined in a set of propositions called the Theory of Intentions ($\mathcal{TI}$)~\citep{blount_towards_2014}.

\subsubsection{Theory of Intentions ($\mathcal{TI}$)}
\label{subsubsec:theory_of_intentions}

The Theory of Intentions ($\mathcal{TI}$) is a framework of static and dynamic laws that maintain an agent's mental state.
Elements of the agent's mental state include the currently selected goal $G$, stored in the $active\_goal\left(G\right)$ inertial fluent, the current planned activity, stored in the $status(M, k)$ inertial fluent~\citep{blount_towards_2014}.
When either a goal is selected or an activity is planned, they are said to be \textit{intended}.

$\mathcal{TI}$ updates the agent's mental states through mental actions.
For example, the action $start(M)$ initiates the agent's intention to execute activity $M$ and $stop(M)$ terminates the agent's intention to execute $M$~\citep{blount_towards_2014}.
Though most actions are executed by the agent itself, some must be executed by the agent's controller.
There are two such actions that are exogenous to the agent.
The exogenous mental action $select(G)$ causes the agent to intend to achieve goal $G$~\citep{blount_towards_2014}.
Likewise, the exogenous mental action $abandon(G)$ causes the agent to cease its intent to achieve goal $G$~\citep{blount_towards_2014}.
These actions are necessarily exogenous because, in general, a goal-driven agent must be told to achieve at least one goal beforehand.

\subsubsection{Domain History}
\label{subsubsec:domain_history}

Previously, we mentioned that a differing aspect of the $\mathcal{AIA}$ architecture is that an agent can attempt an action but fail to do so.
This has significant implications on how the agent's history is represented.
Suppose an agent in the AAA architecture has the following action description (borrowed from~\citep{blount_towards_2014}):

\begin{gather}
    a_1 \textbf{ causes } f \\
    a_2 \textbf{ causes } g \textbf{ if } f, p \\
    b \textbf{ causes } \neg p
\end{gather}

Suppose the agent has the following history\footnotemark:
\begin{equation}
    \Gamma=\{obs\left(p,true,0\right),obs\left(f,false,0\right),hpd\left(a_{1,}0\right),hpd\left(a_{2,}1\right),obs\left(g,false,2\right)\}
\end{equation}
where $obs(F, V, I)$ denotes that the fluent $F$ was observed to have value $V$ at time step $I$ and $hpd(a, I)$ that action $a$ happened at time step $I$.

\footnotetext{
    \citet{blount_towards_2014} uses a slightly different notation than what \citet{balduccini_aaa_2008} introduced.
    \citet{balduccini_aaa_2008} denote the $obs$ predicate as $obs(FluentName, TimeStep, FluentValue)$ whereas \citet{blount_towards_2014} writes $obs(FluentName, FluentValue, TimeStep)$ to denote the same history.
    Since these notations are equivalent and merely a matter of preference, this paper will use the style introduced by \citet{blount_towards_2014}.
}

This history is inconsistent, since the execution of action $a_2$ should have caused $g$ ($g$ is still false afterwards).
The $\mathcal{AIA}$ architecture avoids this inconsistency by adding two history statements.
When executing an action $a$ at time step $I$, the agent records its attempt to do so with $attempt(a, I)$.
During the $I+1$ iteration of the control loop, the agent records $hpd(a, I)$ if the effects of the previous action are observed, otherwise $\neg hpd(a, I)$.
Thus, an agent in the $\mathcal{AIA}$ architecture will have the following history for the previous example

\begin{multline}
    \Gamma=\{
        obs\left(p,true,0\right),obs\left(f,false,0\right),attempt(a_1, 0),hpd\left(a_{1,}0\right) \\
        attempt(a_2, 1), \neg hpd\left(a_{2,}1\right),obs\left(g,false,2\right)
    \}
\end{multline}

This history is consistent.

\subsubsection{Control Loop}
\label{subsubsec:control_loop}

An agent in the $\mathcal{AIA}$ architecture performs the following loop:

\begin{enumerate}
    \item Interpret observations.
    \item Find intended action $A$.
    \item Attempt to perform $A$;
        record this attempt in history.
    \item Observe the world;
        record observations in history.
    \item Repeat (i.e.~go to step 1).
\end{enumerate}

\subsubsection{Examples}
\label{subsubsec:aia_examples}

To demonstrate the execution of an agent in the $\mathcal{AIA}$ architecture, we will consider an example given by \citet{blount_architecture_2013}.
Suppose that we have an agent named Bob in a workspace with a colleague named John.
The workspace in which they are located has four consecutive rooms $r_1$, $r_2$, $r_3$, $r_4$ with a door connecting each adjacent room.
Both Bob and John are free to \textit{move} from their current room to an adjoined one.
The only exception is that the door joining $r_3$ and $r_4$ has a lock and must be in an unlocked state in order for anything to pass through it.
Both Bob and John can \textit{lock} and \textit{unlock} the door when next to it.
A visual description of this example is shown in \cref{fig:aia_example}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Figures/AIA_Architecture/Example_1}
    \caption{Visual depiction of $\mathcal{AIA}$ example}
    \label{fig:aia_example}
\end{figure}

\subsubsection{Scenario 1: Planning to Achieve Goal~\citep{blount_towards_2014}}
\label{subsubsec:aia_scenario_1}

Initially, Bob knows that he is currently located in $r_1$ and John is located in $r_3$.
Suppose Bob is given an order to meet with John.
This is represented as the occurrence of an exogenous mental action $select(meet(Bob, John))$, which eventually causes the $active\_goal(meet(Bob, John))$ fluent to be true in the agent's mental state.
In the first iteration of the $\mathcal{AIA}$ control loop, the agent will:

\begin{enumerate}
    \item Interpret its prior observations, of which there are none.
    \item Find an intended action $A$.
        Since there is not yet an intended goal, the agent will choose to execute the \textit{wait} action, which has no physical or mental effects.
    \item The agent will attempt to execute the \textit{wait} action and record this attempt in its history.
    \item The agent observes the occurrence of the $select(meet(Bob, John))$ exogenous action and record it.
\end{enumerate}

Then, in the second iteration of the loop, the agent will interpret its observations.
According to the $\mathcal{TI}$ laws, this will cause the $active\_goal(meet(Bob, John))$ fluent to be true.
Now, when it will search for an activity which has been described to achieve this goal.
Suppose it chooses the activity $<1, [move(Bob, r_1,r_2), move(Bob, r_2, r_3)],meet(Bob,John)>$.
This is represented by the following inertial fluent $status(1,0)$.
The rest of the second iteration is as follows:

\begin{enumerate}
    \setcounter{enumi}{1}
    \item Find intended action $A$.
        This is the $k + 1$ action of the activity where $status(1, k)$.
        In this case, $A$ is $\{move(Bob, r_1, r_2)\}$.
    \item Execute $move(Bob, r_1, r_2)$.
        Record $attempt(move(Bob, r_1, r_2, 1)$ in history.
    \item Observe that Bob is in $r_2$.
        Record $hpd(move(Bob, r_1, r_2),1)$ in history.
\end{enumerate}

When interpreting its observations in the third iteration of the loop, it will update $status(1,0)$ to $status(1,1)$.
The agent in following steps will intend to execute $move(Bob, r_2, r_3)$, attempt to execute it and store $attempt(move(Bob, r_2, r_3))$ in history, and observe that Bob is in $r_3$ and that it has met with John.
Having accomplished its goal, the $active\_goal(meet(Bob, John))$ fluent is set to false and the agent performs the \textit{wait} action until it is given another goal.

\subsubsection{Scenario 2: Serendipitous Achievement of Goal~\citep{blount_towards_2014}}
\label{subsubsec:aia_scenario_2}

Let us rewind the previous scenario such that the agent Bob is currently attempting $move(Bob, r_1, r_2)$.
Suppose that, during the same time step, the following exogenous action occurs $move(John, r_3, r_2)$.
When Bob observes and records the world, it will record $hpd(move(Bob, r_1, r_2), 1)$ and $hpd(move(John,r_3,r_2), 1)$.
In the next iteration of the control loop, Bob will interpret his observations and derive the $meet(Bob, John)$ fluent to be true.
In this case, Bob's goal to achieve $meet(Bob, John)$ is serendipitously satisfied.
Since Bob wants to maintain this state, it will intend to perform action $stop(1)$ to halt the execution of activity $1$.
Bob will attempt to perform $stop(1)$ while updating the history.
Bob will observe and record $hpd(stop(1), 2)$, at which point Bob will choose to wait indefinitely.

\subsubsection{Scenario 3: Replanning~\citep{blount_towards_2014}}
\label{subsubsec:aia_scenario_3}

Let us again rewind Scenario 1 such that Bob is currently attempting $move(Bob, r_1, r_2)$.
Suppose that, during the same time step, the following exogenous action occurs $move(John, r_3, r_4)$.
When Bob interprets this observation, it will recognize that activity $1$ is \textit{futile} (i.e.~it will not satisfy its goal) and so intend to stop activity $1$.
Bob will attempt to perform $stop(1)$, observe that $stop(1)$ has occurred, re-interpret its observations, and search for a new action to perform.
In this step, Bob will look for an activity that satisfies the goal $meet(Bob, John)$.
Suppose it finds the following activity $<2, [move(Bob, r_2,r_3), move(Bob, r_3,r_4)],meet(Bob,John)>$.
Then Bob will intend to perform $start(2)$.
After Bob attempts to perform $start(2)$, it will observe that $start(2)$ happened, interpret its observations, then search for an intended action.
Bob will intend to perform $move(Bob, r_2,r_3)$, attempt to perform it, observe that it happened, interpret its observations, and so on and so forth.
Assuming that $d_{34}$ is unlocked, the scenario will finish like in Scenario 1.

\subsubsection{Scenario 4: Abandoning Goal~\citep{blount_towards_2014}}
\label{subsubsec:aia_scenario_4}

Moving back to Scenario 1 where Bob is currently attempting $move(Bob, r_1, r_2)$.
Suppose that, during the same time step, the following exogenous action occurs $abandon(meet(Bob, John))$.
Then, when observing this action and interpreting it, the $\mathcal{TI}$ laws will cause $active\_goal(meet(Bob, John))$ fluent to be false.
Subsequently, Bob will intend to stop the current activity (by performing $stop(1)$), attempt to perform $stop(1)$, observe, interpret, and intend to perform \textit{wait} in all future loops.

\subsubsection{Scenario 5: Diagnosis~\citep{blount_towards_2014}}
\label{subsubsec:aia_scenario_5}

Finally, let us reset to the moment in Scenario 1 where Bob is performing $move(Bob, r_2, r_3)$.
When later observing the world, suppose Bob does not find John there in $r_3$.
After recording this observation in the history, Bob then interprets its observations.
Since activity 1 does not achieve the goal $meet(Bob, John)$, Bob begins diagnostic reasoning over the history to figure out how this could be possible.
Looking back in history, there are three possibilities when John could have moved: when Bob performed $start(1)$, when Bob performed $move(Bob, r_1, r_2)$, and when Bob performed $move(Bob, r_2, r_3)$.
Assuming John did not pass Bob while moving between rooms, John must have moved to $r_4$.
In this case, Bob must start an activity $<3, [move(Bob, r_3, r_4)],meet(Bob,John)>$ to move from $r_3$ to $r_4$.
However, before it can do so, it must first perform stop(1) before performing start(3).
Hence, it takes three more iterations of the control loop to move to $r_4$ ($stop(1)$, $start(3)$, $move(Bob, r_3,r_4)$) and one final iteration to end the activity ($stop(3)$).

\section{Logic-based Approaches to Representing and Reasoning over Agent Policies}
\label{sec:policies}

Though the agent architectures discussed thus far allow agents to be fully autonomous, real-world applications may require agents to behave in particular ways.
For example, a controller may want to require an agent to follow certain ethical constraints and may choose to penalize an agent when acting in violation of them.
Thus, it is necessary to introduce a discussion on policies for agent behavior and a formalism with which agents can deduce the compliance of their actions.

\subsection{Language $\mathcal{APL}$}
\label{subsec:apl}

\citet{gelfond_authorization_2008} introduce language the Authorization Policy Language ($\mathcal{APL}$) to represent authorization policies.
An authorization policy is a set of conditions that denote whether an agent's action is permitted or not permitted~\citep{gelfond_authorization_2008}.
In contrast to the languages discussed previously, $\mathcal{APL}$ is not an action language in and of itself.
$\mathcal{APL}$ describes only the conditions under which actions are permitted or forbidden.
It works in conjunction with action languages such as $\mathcal{AL}$.

\subsubsection{Definition}

Similar to the action languages, $\mathcal{APL}$ requires that the agent's environment be modeled by a transition system $T=<\boldsymbol{V},\boldsymbol{F},\boldsymbol{A}>$.
Recall that $T$ contains all trajectories of the underlying system.
An agent's policy $P$ is the subset of the trajectories of $T$ that are desired by the agent's controller.

\citet{gelfond_authorization_2008} provide a mechanism for describing a policy $P$ by means of \textit{authorization} policy statements.
Thus, a policy $P$ is the set of these statements.
These policies are transcribed using static laws in a similar form to action language $\mathcal{AL}$.

\begin{definition}
    \label{def:authorization_statements}
    Authorization policy statements are static laws of the form~\citep{gelfond_authorization_2008}:

    \begin{gather}
        permitted\left(a\right) \textbf{ if } F \\
        \neg permitted\left(a\right) \textbf{ if } F \\
        \textbf{normally } permitted(a) \textbf{ if } F \\
        \textbf{normally } \neg permitted(a) \textbf{ if } F
    \end{gather}

    \noindent
    where $a \in \boldsymbol{A}$ is an action and $F$ is a, possibly empty, conjunction of fluents, actions, or their negations.
    Formally, $F$ is as follows for a state $s$:\footnotemark
    \begin{multline}
        F\subseteq\{V(f,s)=y | (f, y) \in \boldsymbol{F} \times \boldsymbol{V}\} \cup \boldsymbol{A} \cup \{\neg a | a \in \boldsymbol{A}\} \\ \cup \{permitted(a) | a \in \boldsymbol{A}\} \cup \{\neg permitted(a) | a \in \boldsymbol{A}\}
    \end{multline}

    \footnotetext{
        \citet{gelfond_authorization_2008} use the syntax $f = y$ to denote $V(f, s)=y$ for the current state $s$.
        Usages of this new syntax have been translated in terms of the notation already introduced in this paper so as to highlight the connection between previous concepts.
    }
\end{definition}

\begin{definition}
    \label{def:permission}
    \label{def:denial}
    ~

    \begin{itemize}
        \item A \textit{permission} is a statement of the form $permitted(a)$~\citep{gelfond_authorization_2008}.
        \item A \textit{denial} is a statement of the form $\neg permitted(a)$~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:strict_authorization_statements}
    A \textit{strict} authorization policy statement is a statement of the form~\citep{gelfond_authorization_2008}:
    \begin{gather*}
        permitted\left(a\right) \textbf{ if } F \\
        \neg permitted\left(a\right) \textbf{ if } F
    \end{gather*}
\end{definition}

\begin{definition}
    \label{def:defeasible_authorization_statements}
    A \textit{defeasible} authorization policy statement is a statement of the form~\citep{gelfond_authorization_2008}:
    \begin{gather*}
        \textbf{normally } permitted(a) \textbf{ if } F \\
        \textbf{normally } \neg permitted(a) \textbf{ if } F
    \end{gather*}
\end{definition}

Defeasible authorization policy statements permit exceptions when they are in conflict with other authorization statements of higher importance.
To encode the relative hierarchy of defeasible statements, \citet{gelfond_authorization_2008} provide an option to label defeasible statements with terms $d_1,d_2,\dots,d_n$ and use the static $prefer\left(d_i,d_j\right)$ to prioritize statement $d_i$ over statement $d_j$.
Thus, defeasible authorization policy statements can be written in the following form~\citep{gelfond_authorization_2008}.
\begin{gather}
    d_i: \textbf{normally } permitted(a) \textbf{ if } F \\
    d_j: \textbf{normally } \neg permitted(a) \textbf{ if } F \\
    prefer(d_i, d_j)
\end{gather}
If a defeasible authorization policy statement is not referenced in a $prefer$ static, then its corresponding label is optional.

\subsubsection{Semantics}

To explain the semantics of $\mathcal{APL}$, we will borrow an example policy from \citet{gelfond_authorization_2008}.
Suppose in a military context, military personnel are given the following rules:

\begin{itemize}
    \item A military officer is not allowed to command a mission he authorized.
    \item A colonel is allowed to command a mission he authorized.
    \item A military observer is never allowed to authorize a mission.
\end{itemize}

For reference, information on military ranking is provided below:

\begin{itemize}
    \item A colonel is a high-ranking military officer.
    \item An officer of any rank outranks an observer.
\end{itemize}

Suppose we have a transition system $T=<\boldsymbol{V}=\{t,f\},\boldsymbol{F},\boldsymbol{A}>$, where
\begin{gather}
    \boldsymbol{A}=\{authorize(C,M),\ assume\_command(C, M)\} \\
    \boldsymbol{F}=\{authorized(C,M),\ commands(C,M),\ colonel(C),\ observer(C)\}
\end{gather}
and $M$ and $C$ are variables that range over all missions and commanders, respectively.

As a policy designer, we might interpret the first statement as defeasible as there might be a rare scenario where an officer might be forced to command his own mission.
So, we might write:
\[
\textbf{normally } \neg permitted(assume\_command(C, M)) \textbf{ if } authorized(C, M)
\]
\citet{gelfond_authorization_2008} interpret the second statement as defeasible as well.
Thus, we could write:
\[
\textbf{normally } permitted(assume\_command(C, M)) \textbf{ if } colonel(C)
\]

It is important to note that our policy is ambiguous at this point.
In the case a colonel authorized a mission and begins to command it, he would be both compliant and non-compliant.
To clarify, we will add labels to the previous statements then prefer honoring the second statement over the first.
\begin{gather}
    d_1(C, M): \textbf{normally } \neg permitted(assume\_command(C, M)) \textbf{ if } authorized(C, M) \label{eq:apl_example_policy_1} \\
    d_2(C, M): \textbf{normally } permitted(assume\_command(C, M)) \textbf{ if } colonel(C) \label{eq:apl_example_policy_2} \\
    prefer(d_2(C,M),d_1(C,M)) \label{eq:apl_example_policy_3}
\end{gather}

Lastly, the third policy statement can be represented with a strict authorization statement.
\begin{equation}
    \label{eq:apl_example_policy_4}
    \neg permitted(authorize(C, M)) \textbf{ if } observer(C)
\end{equation}

In total, our policy $P$ be the set of the above two statement blocks (\cref{eq:apl_example_policy_1,eq:apl_example_policy_2,eq:apl_example_policy_3,eq:apl_example_policy_4}).

\subsubsection{Answer Set Programming}
\label{subsubsec:asp}

To check the compliance of an action with a given policy, Gelfond and Lobo [12] first translate the policy into a logic program using Answer Set Programming.
\textit{Answer Set Programming} (ASP) is a form of declarative programming geared towards quickly searching NP problems~\citep{vladimir_lifschitz_what_2008}.
It has its foundations in Knowledge Representation and Reasoning, Logic Programming, Databases, and Boolean Constraint Solving~\citep{gebser_potassco_2011}.
Though its syntax resembles that of Prolog, ASP's execution is very different and resembles that of Satisfiability Testing (SAT)~\citep{gebser_potassco_2011,vladimir_lifschitz_what_2008}.
Its execution comes in two stages: grounding and solving~\citep{gebser_potassco_2011}.

The language itself is called \textit{Answer Set Prolog} (or \textit{AnsProlog*} or \textit{A-Prolog} in older literature~\citep{baral_answer_2004}) whereas the paradigm as a whole is called \textit{Answer Set Programming}.

% It is based on stable model semantics~\citep{gelfond_stable_1988}.

Below we will briefly define the syntax of ASP.
For a more thorough definition, we direct the reader to \citet{calimeri_asp-core-2_2020,gebser_abstract_2015}.

\begin{definition}
    A \textit{signature} is a four tuple $\Sigma = <\mathcal{O}, \mathcal{F}, \mathcal{P}, \mathcal{V}>$, where $\mathcal{O}$, $\mathcal{F}$, $\mathcal{P}$, $\mathcal{V}$ are mutually disjoint sets of objects, functions, predicates, and variables, respectively~\citep{blount_architecture_2013}.
\end{definition}

\begin{definition}
    A \textit{term} over a signature $\Sigma$ consists of any of the following~\citep{blount_architecture_2013}:
    \begin{itemize}
        \item Variables
        \item Object constants
        \item $f(t_1, t_2, \dots, t_n)$, if $t_1, t_2, \dots, t_n$ are terms and $f$ is a function symbol with arity $n$
    \end{itemize}
    For simplicity, we use infix notation for arithmetic expressions (e.g. $1+2$ instead of $+(1, 2)$).
\end{definition}

% \begin{definition}
%     An \textit{atom} is
% \end{definition}

\begin{definition}
    A \textit{literal} is either an atom $a$ or its negation $\neg a$~\citep{balduccini_asp_2011}.
\end{definition}

\begin{definition}
    A term/literal is called \textit{ground} if it does not contain any variables or arithmetic functions~\citep{blount_architecture_2013}.
\end{definition}

\begin{definition}
    A \textit{rule} is a statement of the form~\citep{balduccini_asp_2011}:
    \begin{equation}
    h_1 \lor h_2 \lor \dots \lor h_k \leftarrow l_1, l_2, \dots, l_m, \textbf{ not } l_{m+1}, \textbf{ not } l_{m+2}, \dots, \textbf{ not } l_n
    \end{equation}
    where $h_1, h_2, \dots, h_n$ and $l_1, l_2, \dots, l_n$ are ground literals.
    $\textbf{not}$ refers to default negation~\citep{balduccini_asp_2011}.
\end{definition}

\begin{definition}
    A \textit{constraint} is a rule where $\{ h_1, h_2, \dots, h_n \} = \emptyset$~\citep{balduccini_asp_2011}.
\end{definition}

\begin{definition}
    ``A program is a pair $<\Sigma, \Pi>$ where $\Sigma$ is a signature and $\Pi$ is a set of rules over $\Sigma$~\citep{balduccini_asp_2011}''
\end{definition}

\begin{definition}
    An \textit{answer set} or \textit{model} of a program $\Pi$ is a collection of the consequences of $\Pi$ under ASP semantics~\citep{balduccini_asp_2011}.
    More formally,

    \textbf{Case 1:} Program $\Pi$ consists only of rules without default negation~\citep{blount_architecture_2013}, e.g. those of the form:
    \begin{equation}
        h_1 \lor h_2 \lor \dots \lor h_k \leftarrow l_1, l_2, \dots, l_m
    \end{equation}

    An answer set of $\Pi$ is a consistent set S of ground literals such that~\citep{blount_architecture_2013}:
    \begin{itemize}
        \item ``$S$ satisfies the rules of $\Pi$''~\citep{blount_architecture_2013}.
        \item ``$S$ is minimal, i.e. there is no proper subset of $S$ which satisfies the rules of $\Pi$''~\citep{blount_architecture_2013}.
    \end{itemize}

    \textbf{Case 2:} $\Pi$ is an arbitrary program.
    Let $S$ is a set of ground literals.
    Let $\Pi^S$ be a derivative program of $\Pi$ (called the \textit{reduct} of $\Pi$ with respect to $S$) such that:
    \begin{itemize}
        \item For all literals $l \in S$, remove all rules that contain $\textbf{not } l$
        \item Remove all other clauses containing $\textbf{not}$
    \end{itemize}
    $S$ is an answer set of $\Pi$ if $S$ is an answer set of $\Pi^S$ (see Case 1)~\citep{blount_architecture_2013}.
\end{definition}

$\Pi$ can have multiple answer sets.
For example, the following program (borrowed from \citet{balduccini_asp_2011}):
\begin{gather}
    p \leftarrow \textbf{ not } q. \\
    q \leftarrow \textbf{ not } p.
\end{gather}
has two answer sets: $\{p\}$ and $\{q\}$.

In the case when the condition of a constraint is satisfied, $\Pi$ will have zero answer sets (and will be called \textit{inconsistent} or \textit{unsatisfiable}).
For example, the following program:
\begin{gather}
    p. \\
    \leftarrow p. \label{eq:asp_constraint_example}
\end{gather}
is inconsistent since the literals of constraint \ref{eq:asp_constraint_example} are satisfied (i.e. $p$ is true).

In order to simplify the expression of alternatives for which multiple answer sets can be created, ASP also supports constraint literals~\citep{balduccini_asp_2011}.

\begin{definition}
    A \textit{constraint literal} is an expression of the form~\citep{balduccini_asp_2011}:
    \begin{equation}
        m\{l_1,l_2, \dots, l_k\}n
    \end{equation}
    where $ l_1,l_2, \dots, l_k $ are literals and $m$, $n$ are arithmetic expressions.
    This expression is satisfied when $m \le |\{ l_1,l_2, \dots, l_k\}| \le n$.

    To simplify this syntax even further, one can also use variables to simplify a constraint literal such as~\citep{balduccini_asp_2011}:
    \begin{equation}
        m\{l(a_1, b_2),l(a_2,b_2), \dots, l(a_k, b_k)\}n
    \end{equation}
    into an expression of the form:
    \begin{equation}
        m\{l(A, B) : dom_a(A), dom_b(B)\}n
    \end{equation}
    where $dom_a$ and $dom_b$ are function symbols that define the domain of variables $A$ and $B$, respectively.
\end{definition}

With the \textsc{clingo} grounder/solver\footnotemark, arithmetic expressions can also be expanded to evaluate the value of external functions~\citep{gebser_potassco_2019}.
\footnotetext{
    \textsc{clingo}~\citep{gebser_potassco_2011} is available for download at \url{https://potassco.org/clingo/}
}
\textsc{clingo} allows external functions to be written in Python, Lua, C, Rust, or Haskell, though the latter two have not yet reached a stable API~\citep{roland_kaminski_potasscoclingo_2020,sven_thiele_potasscoclingo-rs_2020,paul_ogris_tsahytclingo-haskell_2020}.
External functions can either be included inline or provided externally\footnotemark.
\footnotetext{
    Only Python and Lua are supported inline.
    \textsc{clingo} must be compiled with Python and/or Lua support for inline syntax to be executed.
}

For example, the program:
\lstinputlisting[language=Prolog]{Figures/ASP/inline_function.lp}
is equivalent to:
\lstinputlisting[language=Prolog]{Figures/ASP/base_equivalent.lp}

While the above example is very trivial, it demonstrates a very powerful technique in which computations or queries can be delegated to functions in traditional programming languages.
This being said, external functions should not be used to achieve side-effects.
Unlike Prolog, \textsc{clingo} evaluates rules and calls external functions nondeterminstically according to internal heuristics.
As such, a developer using \textsc{clingo} has little control over the values with which an external function is called.
A developer can only define domain for variable values, by inserting or removing facts and production rules.

\subsubsection{Checking Compliance}

As mentioned previously, \citet{gelfond_authorization_2008} use ASP to check the compliance of an action $A$ at state $s$ with a policy $P$.
To do so, \citet{gelfond_authorization_2008} define the function $lp(P,s)$ to translate $P$ into an executable ASP program as follows:

\begin{gather}
    lp(P,s) =_{def} lp(P)\cup lp(s). \label{eq:apl_lp_01} \\
    lp(P)=_{def}\{lp(statement) | statement \in P\} \label{eq:apl_lp_02} \\
    lp\left(V(f,s)=y\right) =_{def}
        val\left(f,y\right). \label{eq:apl_lp_03} \\
    lp(permitted(a)) =_{def}
        permitted(a). \label{eq:apl_lp_04} \\
    lp(\neg permitted(a)) =_{def}
        \neg permitted(a). \label{eq:apl_lp_05} \\
    lp(permitted(a) \textbf{ if } F) =_{def}
        permitted(a) \leftarrow
            lp(F). \label{eq:apl_lp_06} \\
    lp(\neg permitted(a) \textbf{ if } F) =_{def}
        \neg permitted(a) \leftarrow
            lp(F). \label{eq:apl_lp_07}
\end{gather}
\begin{multline}
    \label{eq:apl_lp_08}
    lp(d_i: \textbf{normally } permitted(a) \textbf{ if } F_i) =_{def} \\
        permitted(a) \leftarrow
            lp(F),
            \textbf{not } ab(d),
            \textbf{not } \neg permitted(a).
\end{multline}
\begin{multline}
    \label{eq:apl_lp_09}
    lp(d_j: \textbf{normally } \neg permitted(a) \textbf{ if } F_j) =_{def} \\
        \neg permitted(a) \leftarrow
        lp(F),
        \textbf{not } ab(d),
        \textbf{not } permitted(a).
\end{multline}
\begin{gather}
    lp(prefer(d_i, d_j)) =_{def}
        ab(d_j) \leftarrow lp(F_1). \label{eq:apl_lp_10}
\end{gather}

\noindent
where $lp(s)$ is the logic encoding of the current state, following an approach like that by \citet{balduccini_aaa_2008}.
If S is a set of atoms, then $lp(S)=_{def}\{lp(atom) | atom \in S\}$

In order to maintain a continuity of syntax between the work of \citet{gelfond_action_1998,balduccini_aaa_2008,blount_architecture_2013,gelfond_authorization_2008}, if $\boldsymbol{V} = \{t,f\}$, this paper will adjust $lp$ such that the following translation written in syntax provided by \citet{gelfond_authorization_2008}:
\[
    lp\left(V(f,s)=y\right) =_{def}
        val\left(f,y\right).
\]
will be simplified to resemble the syntax of \citet{gelfond_action_1998,balduccini_aaa_2008,blount_architecture_2013} as follows:
\begin{gather}
    lp\left(V(f,s)=t\right) =_{def}
        f. \\
    lp\left(V(f,s)=f\right) =_{def}
        \neg f. \\
\end{gather}

\begin{definition}
    \label{def:lp_consistent}
    \label{def:lp_categorical}
    ~

    \begin{itemize}
        \item A logic program is \textit{consistent} if it produces at least one answer set~\citep{gelfond_authorization_2008}.
        \item A logic program is \textit{categorical} if it produces exactly one answer set~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:authorization_consistent}
    \label{def:authorization_categorical}
    ~

    \begin{itemize}
        \item An authorization policy $P$ for transition system $T$ is \textit{consistent} if for every state $s$ of $T$, logic program $lp(P, s)$ is consistent~\citep{gelfond_authorization_2008}.
        \item An authorization policy $P$ for transition system $T$ is \textit{categorical} if for every state $s$ of $T$, logic program $lp(P, s)$ is categorical~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:entails}
    If a consistent logic program $\Pi$ has a literal $l$ which belongs to every answer set of $\Pi$, $\Pi$ \textit{entails} $l$~\citep{gelfond_authorization_2008}.
\end{definition}

\begin{definition}
    Let $P$ be a consistent authorization policy for transition system $T$.

    \begin{itemize}
        \item $permitted(a) \in P(s)$ iff a logic program $lp(P, s)$ entails $permitted(a)$~\citep{gelfond_authorization_2008}.
        \item $\neg permitted(a) \in P(s)$ iff a logic program $lp(P, s)$ entails $\neg permitted(a)$~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:authorization_event_compliance}
    ~

    \begin{itemize}
        \item An event $<s, A>$ is \textit{strongly compliant} with $P$ if~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \forall a \in A\ permitted(a) \in P(s)
            \end{equation}
        \item An event $<s, A>$ is \textit{weakly compliant} with $P$ if~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \forall a \in A\ \neg permitted(a) \not \in P(s)
            \end{equation}
        \item An event $<s, A>$ is \textit{non-compliant} with $P$ if~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \exists a \in A\ \neg permitted(a) \in P(s)
            \end{equation}
    \end{itemize}
\end{definition}

\begin{definition}
    \label{def:authorization_path_compliance}
    A path $<s_0, A_0, s_1, A_1, \dots, s_{n-1}, A_{n-1}, s>$ of transition system $T$ can be similarly categorized into \textit{strongly compliant} or \textit{weakly compliant} if every event $<s_i, A_i>$ along the path for $0 \le i < n$ also has the same classification~\citep{gelfond_authorization_2008}.
    If the path has at least one non-compliant event, then the path is \textit{non-compliant}.
\end{definition}

To demonstrate compliance checking, \citet{gelfond_authorization_2008} will use their working example in the context of particular missions and commanders.
Let $P_m$ be a policy constructed in the form of $P$ for a mission $m_1$ and a colonel $c_1$.
$P_m$ is as follows:
\begin{gather}
    d_1(c_1, m_1): \textbf{normally } \neg permitted(assume\_command(c_1, m_1)) \textbf{ if } authorized(c_1, m_1) \\
    d_2(c_1, m_1): \textbf{normally } permitted(assume\_command(c_1, m_1)) \textbf{ if } colonel(c_1) \\
    prefer(d_2(c_1,m_1),d_1(c_1,m_1)) \\
    \neg permitted(authorize(c_1, m_1)) \textbf{ if } observer(c_1)
\end{gather}

The logic translation of $P_m$, $lp(P_m)$ is the following:
\lstinputlisting[language=Prolog]{Figures/APL_Language/01_Initial_Example/Pm.lp}

Suppose the agent's environment can be represented by the following state:
\begin{equation}
    s_0 = \{colonel(c1), authorized(c1,m1), \neg commands(c1,m1), \neg observer(c1) \}
\end{equation}
Its logic encoding $lp(s_0)$ would be:
\lstinputlisting[language=Prolog]{Figures/APL_Language/01_Initial_Example/s0.lp}

Then, to check the compliance of actions $A \in \mathcal{P}(\boldsymbol{A})$, one would first execute the logic program in an ASP grounder and solver such as \textsc{clingo}.
Doing so, we can see that the logic program $lp(P_m, s_0)$ entails the following answer set:
\lstinputlisting{Figures/APL_Language/01_Initial_Example/run.clingo.txt}

Considering actions $A=\{assume\_command(c_1, m_1)\}$, since $a = assume\_command(c_1, m_1)$ is the only element of $A$ and $lp(P_m, s_0)$ entails $permitted(assume\_command(c_1, m_1))$, $A$ is strongly compliant with $P_m$.

For completeness, one might be curious to consider an action such as:
\begin{equation}
    A = \{assume\_command(c_1, m_1), authorize(c_1, m_1)\}
\end{equation}
While such an action would be weakly compliant according to $P_m$ (since $permitted(authorize(c_1, m_1))$ is missing but neither $\neg permitted(assume\_command(c_1, m_1))$ or $\neg permitted(authorize(c_1, m_1))$ is present), a designer would likely render this combination of actions invalid by accompanying $P_m$ with an action description in $\mathcal{AL}$.
Such an action description might look like the following:

\begin{gather}
    \neg observer(c_1) \textbf{ if } colonel(c_1) \label{eq:apl_action_description_5} \\
    authorize(c_1, m_1) \textbf{ causes } authorized(c_1, m_1) \label{eq:apl_action_description_1} \\
    assume\_command(c_1, m_1) \textbf{ causes } commands(c_1, m_1) \label{eq:apl_action_description_2} \\
    \textbf{impossible } authorize(c_1, m_1) \textbf{ if } authorized(c_1, m_1) \label{eq:apl_action_description_3} \\
    \textbf{impossible } assume\_command(c_1, m_1) \textbf{ if } commands(c_1, m_1) \label{eq:apl_action_description_4}
\end{gather}

Intuitively, if $c_1$ has already authorized $m_1$, he cannot authorize it again.
Likewise, if $c_1$ has already assumed command of $m_1$, he cannot begin to assume command of it again.
Thus, actions $A = \{assume\_command(c_1, m_1), authorize(c_1, m_1)\}$ is impossible and is not a valid candidate for checking policy compliance.
$A = \{authorize(c_1, m_1)\}$ is also impossible.

Considering $A=\emptyset$, $A$ is possible according to the action description.
With respect to $P_m$, $A$ is weakly compliant since neither $permitted(wait)$ or $\neg permitted(wait)$ is entailed by $lp(P_m, s_0)$.

\subsubsection{Checking Compliance with Complete Knowledge of State}

To formalize this approach even further, \citet{gelfond_authorization_2008} provide propositions that decide how compliant an event $<s,a>$ is with an authorization policy $P$.

\begin{definition}
    \label{def:authorization_event_compliance_full_knowledge}
    ~

    \begin{itemize}
        \item An event $<s, a>$ is \textit{strongly compliant} with a consistent policy $P$ for transition system $T$ iff the following logic program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                lp(P, s) \cup \{ \leftarrow permitted(a). \}
            \end{equation}
        \item An event $<s, a>$ is \textit{weakly compliant} with a consistent policy $P$ for transition system $T$ iff the following logic program is inconsistent\footnotemark~\citep{gelfond_authorization_2008}:
            \begin{equation}
                lp(P, s) \cup \{ \leftarrow \textbf{ not } \neg permitted(a). \}
            \end{equation}
        \item An event $<s, a>$ is \textit{non-compliant} with a consistent policy $P$ for transition system $T$ iff the following logic program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                lp(P, s) \cup \{ \leftarrow \neg permitted(a). \}
            \end{equation}
    \end{itemize}
\end{definition}

\footnotetext{
    To improve the readability of this document, the definition of weak compliance has been adjusted from how \citet{gelfond_authorization_2008} define it.
    \citet{gelfond_authorization_2008} define weakly compliance to be when the logic program $lp(P, s) \cup \{ \leftarrow \textbf{ not } \neg permitted(a).\}$ is consistent.
    The provided definition is a simple logical negation of this definition and, hence, is equivalent to it.
}

These propositions are just simple extensions of \cref{def:authorization_event_compliance}.
However, they are useful because they cause an ASP solver to output a Yes/No answer to the problem.
So, continuing the previous example, one would write:
\begin{lstlisting}[language=Prolog]
:- permitted(assume_command(c1, m1)).
\end{lstlisting}
The logic program $lp(P, s) \cup \{ \leftarrow permitted(assume\_command(c_1, m_1)). \}$ results in:
\lstinputlisting{Figures/APL_Language/02_Full_Knowledge/strongly_compliant.clingo.txt}
Since the output is ``unsatisfiable'', $lp(P, s) \cup \{ \leftarrow permitted(a). \}$ is inconsistent and $<s_0, A>$ is strongly compliant.

\subsubsection{Checking Compliance with Partial Knowledge of State}

It is worth noting that the above approach requires complete knowledge of the state $s$ (i.e. the value of all fluents in $s$).
\citet{gelfond_authorization_2008} show that checking policy compliance is also possible when an agent only knows the value of a subset of fluents in $s$.
Let $\boldsymbol{F_{lim}} \subseteq \boldsymbol{F}$ be the subset of fluents for which the agent knows $V(f, s)$ where $f \in \boldsymbol{F_{lim}}$.
Let $V_{lim} = \{V(f, s) | f \in \boldsymbol{F_{lim}}\}$.

\begin{definition}
    \label{def:simple_knowledge_state}
    In contrast to a proper \textit{state} of an action description (where values are assigned to all fluents, provided they satisfy all static laws), $V_{lim}$ describes a \textit{simple-knowledge state} where values are assigned only to some fluents, provided they satisfy relevant static laws~\citep{gelfond_authorization_2008}.
\end{definition}

\begin{definition}
    Let $\delta(V_{lim}) \in S$ be the set of states that contain $V_{lim}$.

    \begin{itemize}
        \item If $\forall s_{possible} \in \delta(V_{lim})$ event $<s_{possible}, a>$ is strongly compliant with $P$, then $a$ is strongly compliant in $s$~\citep{gelfond_authorization_2008}.
        \item If $\forall s_{possible} \in \delta(V_{lim})$ event $<s_{possible}, a>$ is at least weakly compliant with $P$, then $a$ is at least weakly compliant in $s$~\citep{gelfond_authorization_2008}.
        \item If $\forall s_{possible} \in \delta(V_{lim})$ event $<s_{possible}, a>$ is non-compliant with $P$, then $a$ is non-compliant in $s$~\citep{gelfond_authorization_2008}.
        \item If none of the above hold, then $V_{lim}$ does not hold enough information to determine the compliance of $a$ in $s$~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

However, in order to evaluate any of the above statements, an agent needs to first compute $\delta(V_{lim})$.
To do so, \citet{gelfond_authorization_2008} rely on converting an action description in $\mathcal{AL}$ to an ASP logic program and joining it to $lp(P, s)$.
They extend $lp$ to handle static laws from $\mathcal{AL}$ as follows:
\begin{equation}
    lp(V(L,s)=y \textbf{ if } F) =_{def} val(l, y) \leftarrow lp(F).
\end{equation}

Let $SL$ be the set of all static laws from the action description.

Let $D = \{lp(V(f,s)=y_1) \lor lp(V(f,s)=y_2) \lor \dots \lor lp(V(f,s)=y_n) | f \in \boldsymbol{F}\}$, where $y_1, y_2, \dots, y_n \in \boldsymbol{V}$.

\begin{definition}
    $s \in \delta(V_{lim})$ iff lp(s) is an answer set of $lp(V_{lim}) \cup D \cup lp(SL)$~\citep{gelfond_authorization_2008}.
\end{definition}

\begin{definition}
    \label{def:authorization_event_compliance_partial_knowledge}
    ~

    \begin{itemize}
        \item For all states $s_{possible} \in \delta(V_{lim})$, the event $<s_{possible}, a>$ is \textit{strongly compliant} with $P$ iff the following program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \label{eq:authorization_partial_knowledge_strongly_compliant}
                lp(P, s_{possible}) \cup D \cup lp(SL) \cup \{ \leftarrow permitted(a). \}
            \end{equation}
        \item For all states $s_{possible} \in \delta(V_{lim})$, the event $<s_{possible}, a>$ is \textit{weakly compliant} with $P$ if $P$ is categorical and the following program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \label{eq:authorization_partial_knowledge_weakly_compliant}
                lp(P, s_{possible}) \cup D \cup lp(SL) \cup \{ \leftarrow \textbf{ not } \neg permitted(a). \}
            \end{equation}
        \item For all states $s_{possible} \in \delta(V_{lim})$, the event $<s_{possible}, a>$ is \textit{non-compliant} with $P$ iff the following program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \label{eq:authorization_partial_knowledge_non_compliant}
                lp(P, s_{possible}) \cup D \cup lp(SL) \cup \{ \leftarrow \neg permitted(a). \}
            \end{equation}
        \item If $P$ is categorical, then an event $<s_{possible}, a>$, where $s_{possible} \in \delta(V_{lim})$, is also \textit{non-compliant} with $P$ if the program \cref{eq:authorization_partial_knowledge_weakly_compliant} is consistent~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

Continuing the running example, suppose an agent did not know that $c_1$ is a colonel. Then:
\begin{gather}
    \boldsymbol{F_{lim}} = \{ authorized(c_1, m1), commands(c_1, m_1), observer(c_1) \} \\
    V_{lim} = \{ V(authorized(c_1, m1), s) = t, V(commands(c_1, m_1), s) = t, V(observer(c_1), s) = t \}
\end{gather}

$D$ is as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/03_Partial_Knowledge/D.lp}

The static laws from the action description in \cref{eq:apl_action_description_1,eq:apl_action_description_2,eq:apl_action_description_3,eq:apl_action_description_4,eq:apl_action_description_5} can be encoded as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/03_Partial_Knowledge/SL.lp}

The encoding of $\delta(V_{lim})$ is as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/03_Partial_Knowledge/delta_V_lim.lp}

%\lstinputlisting[language=Prolog]{Figures/APL_Language/03_Partial_Knowledge/Pm.lp}

The result of logic program \cref{eq:authorization_partial_knowledge_strongly_compliant} is as follows:
\lstinputlisting{Figures/APL_Language/03_Partial_Knowledge/strongly_compliant.clingo.txt}
Thus $A$ is not strongly compliant with $P_m$.

The result of logic program \cref{eq:authorization_partial_knowledge_weakly_compliant} is as follows:
\lstinputlisting{Figures/APL_Language/03_Partial_Knowledge/weakly_compliant.clingo.txt}
Thus $A$ is not weakly compliant with $P_m$.

The result of logic program \cref{eq:authorization_partial_knowledge_strongly_compliant} is as follows:
\lstinputlisting{Figures/APL_Language/03_Partial_Knowledge/non_compliant.clingo.txt}
However, before we can say $A$ is non-compliant, we must first determine whether $P_m$ is categorical.
To do so, we will rerun the second test giving \textsc{clingo} the option ``0'', which instructs \textsc{clingo} to find every satisfiable model instead of stopping at the first one.
The output of \cref{eq:authorization_partial_knowledge_weakly_compliant} with option ``0'' is as follows:
\lstinputlisting{Figures/APL_Language/03_Partial_Knowledge/non_compliant_categorical.clingo.txt}
Since ``Models: 1'', $P_m$ is categorical and hence $A$ is non-compliant.

\subsubsection{Checking Compliance using a History of Past Actions}

\citet{gelfond_authorization_2008} note that the above two approaches will not work for agents in the AAA architecture (or for that matter, the $\mathcal{AIA}$ architecture).
Nonetheless, they develop a method for checking policy compliance under the AAA architecture knowledge constraints.
As mentioned previously, agents in the AAA architecture have an initial description of their initial state (complete or partial), a history of their actions $A_0, A_1, \dots, A_n$, and may have memory of fluent values at particular points in time.

\citet{gelfond_authorization_2008} define a new function $lp(P, I)$ that adds a step $I$ argument to each ASP atom from $lp(P)$ (\cref{eq:apl_lp_01,eq:apl_lp_02,eq:apl_lp_03,eq:apl_lp_04,eq:apl_lp_05,eq:apl_lp_06,eq:apl_lp_07,eq:apl_lp_08,eq:apl_lp_09,eq:apl_lp_10}).
The new $lp$ function is defined as follows:
\begin{gather}
    lp(P,s,I) =_{def} lp(P,I)\cup lp(s,I). \label{eq:apl_lp_inc_01} \\
    lp(P,I)=_{def}\{lp(statement,I) | statement \in P\} \label{eq:apl_lp_inc_02} \\
    lp\left(V(f,s)=y,I\right) =_{def}
        val\left(f,y,I\right). \label{eq:apl_lp_inc_03} \\
    lp(permitted(a),I) =_{def}
        permitted(a, I). \label{eq:apl_lp_inc_04} \\
    lp(\neg permitted(a),I) =_{def}
        \neg permitted(a, I). \label{eq:apl_lp_inc_05} \\
    lp(permitted(a) \textbf{ if } F, I) =_{def}
        permitted(a, I) \leftarrow
            lp(F, I). \label{eq:apl_lp_inc_06} \\
    lp(\neg permitted(a) \textbf{ if } F, I) =_{def}
        \neg permitted(a, I) \leftarrow
            lp(F, I). \label{eq:apl_lp_inc_07}
\end{gather}
\begin{multline}
    \label{eq:apl_lp_inc_08}
    lp(d_i: \textbf{normally } permitted(a) \textbf{ if } F_i, I) =_{def} \\
        permitted(a, I) \leftarrow
            lp(F, I),
            \textbf{not } ab(d, I),
            \textbf{not } \neg permitted(a, I).
\end{multline}
\begin{multline}
    \label{eq:apl_lp_inc_09}
    lp(d_j: \textbf{normally } \neg permitted(a) \textbf{ if } F_j, I) =_{def} \\
        \neg permitted(a, I) \leftarrow
            lp(F, I),
            \textbf{not } ab(d, I),
            \textbf{not } permitted(a, I).
\end{multline}
\begin{gather}
    lp(prefer(d_i, d_j), I) =_{def}
        ab(d_j, I) \leftarrow lp(F_1, I). \label{eq:apl_lp_inc_10}
\end{gather}

For a history $H_n=<s, A_0, A_1, \dots, A_{n-1}>$, they also add:
\begin{gather}
    lp(a, I)=_{def}occurs(a, I). \\
    lp(P, H) =_{def} lp(P, I) \cup lp(s, 0) \cup lp(A_0, 0) \cup lp(A_1, 1) \cup \dots \cup lp(A_{i-1}, I-1)
\end{gather}

Similar to before, the notation of \citet{gelfond_authorization_2008} will be simplified when $\boldsymbol{V}=\{t,f\}$ so that \cref{eq:apl_lp_inc_03} will represented as:
\begin{gather}
    lp\left(V(f,s)=t,I\right) =_{def}
        val\left(f,I\right). \\
    lp\left(V(f,s)=f,I\right) =_{def}
        -val\left(f,I\right). \\
\end{gather}

Let $D_0 = \{lp(V(f,s)=y_1, 0) \lor lp(V(f,s)=y_2, 0) \lor \dots \lor lp(V(f,s)=y_n, 0) | f \in \boldsymbol{F}\}$, where $y_1, y_2, \dots, y_n \in \boldsymbol{V}$

\begin{definition}
    \label{def:model_of_history}
    A trajectory\footnotemark $s_0, A_0, s_1, A_1, \dots, A_{n-1}, s_n$ of a transition system $T$ is a \textit{model} of a history $H_n = <s, A_0, A_1, \dots, A_{n-1}>$ if $s \subseteq s_0$~\citep{gelfond_authorization_2008}.
    Thus, a trajectory that meets this condition does not contradict what has been recorded in the agent's history.
    \footnotetext{
        \citet{gelfond_authorization_2008} define `trajectory' and `history' in terms of elementary actions in contrast to \citet{blount_architecture_2013,gelfond_action_1998}.
        In order to maintain continuity with the definition of action signatures and transition systems presented in \cref{def:transition_system}, \cref{def:model_of_history} has been extended to include compound actions.
    }
\end{definition}

Let $Check_1(H_n)$ be the following subprogram:
\begin{gather}
    \neg strongly\_compliant \leftarrow occurs(A, I), \textbf{ not } permitted(A, I). \\
    \leftarrow \textbf{ not } \neg strongly\_compliant.
\end{gather}

Let $Check_2(H_n)$ be the following subprogram:
\begin{gather}
    \neg weakly\_compliant \leftarrow occurs(A, I), \neg permitted(A, I). \\
    \leftarrow \textbf{ not } \neg weakly\_compliant.
\end{gather}

\begin{definition}
    \label{def:authorization_event_compliance_history_knowledge}
    ~

    \begin{itemize}
        \item A model of $H_n$ is \textit{strongly compliant} with $P$ iff the following program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \label{eq:authorization_history_knowledge_strongly_compliant}
                lp(P, H_n) \cup D \cup lp(A) \cup Check_1
            \end{equation}
        \item A model of $H_n$ is \textit{weakly compliant} with $P$ iff the following program is inconsistent~\citep{gelfond_authorization_2008}:
            \begin{equation}
                \label{eq:authorization_history_knowledge_weakly_compliant}
                lp(P, H_n) \cup D \cup lp(A) \cup Check_2
            \end{equation}
        \item A model of $H_n$ that is neither strongly compliant nor weakly compliant must be non-compliant~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

Continuing the previous example, the logic encoding of $P_m$ with the new $lp$ function is as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/Pm.lp}

$D_0$ is as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/D0.lp}

Suppose our agent has the following history\footnotemark:
\begin{gather}
    s_0 = \{ colonel(c_1), -observer(c_1), -authorized(c_1, m_1), -commands(c_1, m_1) \} \\
    A_0 = \{ authorize(c_1, m_1) \} \\
    H_1 = < s_0, A_0 >
\end{gather}
and is considering executing action $A_1 = \{ assume\_command(c_1, m_1) \}$ in the current time step 1.
Before executing $A_1$, our agent first wants to verify its compliance.

\footnotetext{
    \citet{gelfond_authorization_2008} use a different notation for describing an agent's history than what was introduced in \cref{subsubsec:domain_history} while describing the work of \citet{blount_towards_2014}.
}

The logic encoding $lp(H_1)$ would be as follows\footnotemark:
\footnotetext{
    It is worth noting that the syntax \citet{gelfond_authorization_2008} provide for $lp(H_1)$ is very similar to that introduced in \citet{blount_towards_2014}.
    Whereas \citet{blount_towards_2014} would write $obs(FluentName, FluentValue, TimeStep)$ and $hpd(ActionName, TimeStep)$,\citet{gelfond_authorization_2008} write $val(FluentName, FluentValue, TimeStep)$ and $occurs(ActionName, TimeStep)$, respectively.
}

\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/Hn.lp}

The logic encoding $lp(A_1)$ is as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/A1.lp}

$Check_1$ and $Check_2$ are as follows:
\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/Check_1.lp}
\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/Check_2.lp}

The output of logic program \cref{eq:authorization_history_knowledge_strongly_compliant} is as follows:
\lstinputlisting{Figures/APL_Language/04_History_Knowledge/Check_1.clingo.txt}

The output of logic program \cref{eq:authorization_history_knowledge_weakly_compliant} is as follows:
\lstinputlisting{Figures/APL_Language/04_History_Knowledge/Check_2.clingo.txt}

By this output, we might be led to say that action $A_1$ is weakly compliant given history $H_n$.
However, \citet{gelfond_authorization_2008} implicitly assume that the inertia property of inertial fluents is already encoded in logic form.
To do this, we must add the following \textit{inertia axiom} for the inertial fluents $authorized(C,M),\ commands(C,M),\ colonel(C),\ observer(C)$:
\lstinputlisting[language=Prolog]{Figures/APL_Language/04_History_Knowledge/Inertia_Axiom.lp}

With this inertia axiom, \cref{eq:authorization_history_knowledge_strongly_compliant} is inconsistent hence action $A_1$ is strongly compliant given history $H_n$.

\lstinputlisting{Figures/APL_Language/04_History_Knowledge/Check_1_with_Inertia_Axiom.clingo.txt}
\lstinputlisting{Figures/APL_Language/04_History_Knowledge/Check_2_with_Inertia_Axiom.clingo.txt}

\subsection{Language $\mathcal{AOPL}$}
\label{subsec:aopl}

In addition to introducing language $\mathcal{APL}$, \citet{gelfond_authorization_2008} introduce the Authorization and Obligation Policy Language ($\mathcal{AOPL}$) to consider \textit{obligation policies} in addition to authorization policies.
Authorization policies describe what an agent can do whereas obligation policies describe what an agent must do.

\subsubsection{Definition}

Language $\mathcal{AOPL}$ uses $\mathcal{APL}$ as its basis and shares its underlying assumptions, such as requiring the agent's environment be modeled by a transition system $T=<\boldsymbol{V}, \boldsymbol{F}, \boldsymbol{A}>$ and that a policy $P$ is a subset of the trajectories of $T$ that are preferable to the agent's controller.

$\mathcal{AOPL}$ adds a $obl(a)$ statement to $\mathcal{APL}$.
If $obl(a)$ is true, the policy $P$ dictates that the agent must execute $a$ in the current state.
If $obl(\neg a)$ is true, then $P$ dictates that the agent must not execute $a$ in the current state.
Also, if $\neg obl(a)$ is true, then $P$ does not require the agent to execute $a$ in the current state (i.e. it is free to choose to execute $a$ or to not execute $a$).
Likewise, for $\neg obl(\neg a)$.

\begin{definition}
    Obligation policy statements are static laws of the form~\citep{gelfond_authorization_2008}:
    \begin{gather}
        obl\left(h\right) \textbf{ if } F \\
        \neg obl\left(h\right) \textbf{ if } F \\
        d_i: \textbf{normally } obl(h) \textbf{ if } F \\
        d_j: \textbf{normally } \neg obl(h) \textbf{ if } F \\
        prefer(d_i, d_j)
    \end{gather}
    where $h \in \boldsymbol{A} \cup \{\neg a | a \in \boldsymbol{A}\}$ is a \textit{happening} and $F$ is a, possibly empty, conjunction of fluents, actions, or their negations.
    Formally, $F$ is as follows for a state $s$:
    \begin{equation}
        F\subseteq\{V(f,s)=y | (f, y) \in \boldsymbol{F} \times \boldsymbol{V}\} \cup \boldsymbol{A} \cup \{\neg a | a \in \boldsymbol{A}\} \cup \{obl(h), \neg obl(h)\}
    \end{equation}
\end{definition}

\subsubsection{Checking Compliance}

To evaluate the compliance of happening $h$ at state $s$ with an obligation policy $P$, \citet{gelfond_authorization_2008} extend $lp$ as follows:

\begin{gather}
    lp(obl(h)) =_{def}
        obl(h). \\
    lp(\neg obl(h)) =_{def}
        \neg obl(h). \\
    lp(obl(h) \textbf{ if } F) =_{def}
        obl(h) \leftarrow
            lp(F). \\
    lp(\neg obl(h) \textbf{ if } F) =_{def}
        \neg obl(h) \leftarrow
            lp(F). \\
    lp(d_i: \textbf{normally } obl(h) \textbf{ if } F_i) =_{def}
        obl(h) \leftarrow
            lp(F),
            \textbf{not } ab(d),
            \textbf{not } \neg obl(h). \\
    lp(d_j: \textbf{normally } \neg obl(h) \textbf{ if } F_j) =_{def}
        \neg obl(h) \leftarrow
            lp(F),
            \textbf{not } ab(d),
            \textbf{not } obl(h). \\
    lp(prefer(d_i, d_j)) =_{def}
        ab(d_j) \leftarrow lp(F_1).
\end{gather}

\begin{definition}
    $obl(h) \in P(s)$ iff the logic program $lp(P, s)$ entails $obl(h)$
\end{definition}

\begin{definition}
    \label{def:obligation_event_compliance}
    An event $<s, A>$ is \textit{compliant} with an obligation policy $P$ if $(\forall obl(a) \in P(s) \ a \in A) \land (\forall obl(\neg a) \in P(s) \ a \not \in A)$
\end{definition}

This definition of compliance contrasts with that for authorization policies.
Given a set of actions $A$, the definition for authorization policies can be thought of first enumerating action $a \in A$ then checking to see if $permitted(a)$ exists.
The definition for obligation policies, by contrast, can be thought of first searching for $obl(a)$ statements, then checking to see if $a \in A$ exists (or $a \not \in A$ in the case of $obl(\neg a)$).

Furthermore, the definition for obligation compliance does not differentiate between strong compliance and weak compliance.
Were such a differentiation to exist, it would center around instances where neither $\neg obl(a)$ nor $obl(a)$ is true\footnotemark.
For such a case, an obligation policy would not explicitly impose nor explicitly waive an agent from an obligation to perform action $a$.
However, since $\mathcal{AOPL}$ does not consider `weak compliance', this situation is simply called \textit{compliant}.

\footnotetext{
    A similar statement can be made about when neither $\neg obl(\neg a)$ nor $obl(\neg a)$ is true.
}

\begin{definition}
    Let $P$ be an arbitrary policy $P$ written in $\mathcal{AOPL}$.

    \begin{itemize}
        \item Let $P_a$ be a derivative policy of $P$ that only has the authorization statements of $P$.
            $P_a$ is an \textit{authorization policy induced by} $P$~\citep{gelfond_authorization_2008}.
        \item Likewise, let $P_o$ be a derivative of $P$ such that $P_o$ only has the obligation statements of $P$.
            $P_o$ is an \textit{obligation policy induced by} $P$~\citep{gelfond_authorization_2008}.
    \end{itemize}
\end{definition}

\begin{definition}
    Let $P$ be an arbitrary policy $P$ written in $\mathcal{AOPL}$.
    Let $P_a$ and $P_o$ be the authorization and obligation policy induced by $P$, respectively.

    \begin{itemize}
        \item An event $<s, A>$ is \textit{strongly compliant} with $P$ if $<s, A>$ is strongly compliant with $P_a$ and if $<s, A>$ is compliant with $P_o$~\citep{gelfond_authorization_2008}.
        \item An event $<s, A>$ is \textit{weakly compliant} with $P$ if $<s, A>$ is weakly compliant with $P_a$ and if $<s, A>$ is compliant with $P_o$~\citep{gelfond_authorization_2008}.
        \item An event $<s, A>$ is \textit{non-compliant} with $P$ if $<s, A>$ is neither strongly compliant nor weakly compliant with $P$\footnotemark.
    \end{itemize}
\end{definition}

\footnotetext{
    This definition is not explicitly provided by \citet{gelfond_authorization_2008}.
}

\subsubsection{Obligation Example}

To demonstrate the compliance of a policy $P$ in $\mathcal{AOPL}$, \citet{gelfond_authorization_2008} present an example.
We have substantially expanded the discussion of their example, regarding both the amount of formal definitions and the overall depth of detail.

Suppose a university professor were to encode his classroom policies into $\mathcal{AOPL}$.
He might have requirements such as:

\begin{itemize}
    \item Students are expected to not miss class.
    \item Students should submit homework on time.
    \item Students should do their homework independently.
\end{itemize}

Before we encode these obligations, we need to first define the transition system for this scenario.
Suppose the environment can be modeled by a transition system $T$ where\footnotemark:

\begin{equation}
    T=<\boldsymbol{V}=\{t,f\}, \boldsymbol{F}, \boldsymbol{A}>
\end{equation}
\begin{multline}
    \boldsymbol{F} = \{enrolled(Student, Class), meeting(Class, MeetingNum), \\
        due\_date(meeting(Class, MeetingNum), assignment(Class, AssignmentNum)), \\
        family\_emergency(Student, meeting(Class, MeetingNum)), \\
        religious\_holiday(meeting(Class, MeetingNum))\}
\end{multline}
\begin{multline}
    \boldsymbol{A} = \{attend(Student, meeting(Class, MeetingNum)), \\
        submit(Student, assignment(Class, AssignmentNum), meeting(Class, MeetingNum)), \\
        accept\_unauthorized\_help(Student)\}
\end{multline}
and $Student$, $Class$, $AssignmentNum$, and $MeetingNum$ are variables that range over their respective values.

\footnotetext{
    The following definitions are only implicit in the work by \citet{gelfond_authorization_2008}.
}

Now that we have a transition system defined, we are ready to transcribe the verbal requirements into policy strict/defeasible statements in $\mathcal{AOPL}$.
\citet{gelfond_authorization_2008} envision possible exceptions to the first rule and, in order to maintain elaboration tolerance, express it with a defeasible obligation statement:
\begin{equation}
    \label{eq:aopl_example_line_1}
    d_1(S,C,N): \textbf{ normally } obl(attend(S, meeting(C, N))) \textbf{ if } enrolled(S, C).
\end{equation}

\citet{gelfond_authorization_2008} assume that such an implicit exception may be ``Students do not need to attend class during family emergencies.''
Its encoding would be as follows:
\begin{equation}
    \label{eq:aopl_example_line_2}
    \neg obl(attend(S,meeting(C, N))) \textbf{ if } family\_emergency(S,meeting(C, N)).
\end{equation}

Similarly, they suggest that another exception may be ``Students should not attend class on a religious holiday.''
Its encoding might be as follows:
\begin{multline}
    \label{eq:aopl_example_line_3}
    d_2(S,C,N): \textbf{ normally } obl(\neg attend(S, meeting(C, N))) \\
        \textbf{ if } religious\_holiday(meeting(C, N)).
\end{multline}

\citet{gelfond_authorization_2008} note that writing this rule as defeasible allows the designer to decide whether religious obligations overrule secular requirements.
If he deems that they do, he may write:
\begin{equation}
    \label{eq:aopl_example_line_4}
    prefer(d_2(S,C,N),d_1(S,C,N))
\end{equation}
Otherwise, he may write:
\begin{equation}
    \label{eq:aopl_example_line_5}
    prefer(d_1(S,C,N), d_2(S,C,N))
\end{equation}

While it is possible to omit such a statement from the policy description, doing so would produce an ambiguous policy that would allow an agent to choose which rule it would prefer to uphold.
\citet{gelfond_authorization_2008} do not recommend allowing this behavior.

The second rule may be seen as defeasible to encompass assignment extensions.
\begin{multline}
    \label{eq:aopl_example_line_6}
    d_3(S,C,A,N): \textbf{ normally } obl(submit(S,assignment(C,A),meeting(C,N)) \\ \textbf{ if } enrolled(S,C), due\_date(meeting(C,N), assignment(C,A)).
\end{multline}
Lastly, since cheating is never permissible:
\begin{equation}
    \label{eq:aopl_example_line_7}
    obl(\neg accept\_unauthorized\_help(S)).
\end{equation}

The policy $P$ consisting of \cref{eq:aopl_example_line_1,eq:aopl_example_line_2,eq:aopl_example_line_3,eq:aopl_example_line_4,eq:aopl_example_line_6,eq:aopl_example_line_7} can be encoded as follows\footnotemark:
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/P.lp}

\footnotetext{
    We have added all of the following ASP code to supplement the discussion by \citet{gelfond_authorization_2008}.
}

To keep logic programs in this example from becoming unnecessarily long, the above source (as well as those that will follow it) will favor the use of ASP variables over the manual enumeration of primitive variable values.
To bind variable values to an ASP variable, we will use the following convention:
\begin{itemize}
    \item If the variable $Student$ ranges over values $student_1, student_2, \dots, student_n$, then it will be encoded as follows:
        \begin{gather}
            student(student_1). \\
            student(student_2). \\
            \dots \\
            student(student_n).
        \end{gather}
    \item If the variable $Class$ ranges over values $class_1, class_2, \dots, class_n$, then it will be encoded as follows:
        \begin{gather}
            class(class_1). \\
            class(class_2). \\
            \dots \\
            class(class_n).
        \end{gather}
    \item If the variable $MeetingNum$ ranges over values $1, 2, \dots, n$, then it will be encoded as follows:
        \begin{equation}
            1, 2, \dots, n
        \end{equation}
    \item If the variable $AssignmentNum$ ranges over values $1, 2, \dots, n$, then it will be encoded as follows:
        \begin{equation}
            1, 2, \dots, n
        \end{equation}
\end{itemize}

\citet{gelfond_authorization_2008} do not provide a concrete example that instantiates all of the above variables.
However, in order to provide a complete discussion of their work, we will use the following variables and the following state $s_0$:
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/instantiate_variables.lp}
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/s0.lp}

Suppose we want to check the compliance of the following occurance of actions $A$:
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/A.lp}

We can check for compliance using the following logic programs\footnotemark:
\footnotetext{
    In what follows, we implement a generic logic program that is capable of checking the compliance of any set of actions $A$ with respect to any arbitrary policy $P$.
    This is for added convenience, since this logic program can simultaneously check the compliance of $A$ with the induced authorization policy $P_a$ as well as the induced obligation policy $P_o$.
    This is a significant improvement from the original definitions presented in \cref{def:authorization_event_compliance_full_knowledge,def:obligation_event_compliance}, since the latter involves invoking \textsc{clingo} twice (once for checking compliance of $A$ with $P_a$ and again for $P_o$) and hardcodes $A$ into the logic program.
}

\lstinputlisting[language=Python]{Figures/AOPL_Language/01_Full_Knowledge/Compliance_Checks/util.lp}
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/Compliance_Checks/authorization_compliance.lp}
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/Compliance_Checks/obligation_compliance.lp}

In the above snippet, the inline Python script is instrumental in differentiating between $obl(a)$ and $obl(\neg a)$.
Given the ASP expression $obl(Action)$, the variable $Action$ can be bound to either $a$ or $\neg a$ (in the case $obl(a)$ is true or $obl(\neg a)$ is true, respectively).
Since $obl(a)$ and $obl(\neg a)$ have different semantics in $\mathcal{AOPL}$, they need to be addressed by two separate rules.
By writing $obl(Action), \ @is\_positive(Action) = true$, the variable $Action$ can only be bound to $a$ (hence only $obl(a)$ will be matched).
To address $obl(\neg a)$, we write $obl(-Action), \ @is\_positive(Action) = true$.

Finally, if we add:
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/Compliance_Checks/strongly_compliant.lp}
we can see that the event $<s_0, A>$ is not strongly compliant:
\lstinputlisting{Figures/AOPL_Language/01_Full_Knowledge/Scripts/01/strongly_compliant.clingo.txt}

Upon further investigation (which is not shown here for brevity), one can see that this is because our policy $P$ does not have any authorization statements.
Hence, no action is strongly compliant.
However, the event $<s_0, A>$ is weakly compliant:
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/Compliance_Checks/weakly_compliant.lp}
\lstinputlisting{Figures/AOPL_Language/01_Full_Knowledge/Scripts/01/weakly_compliant.clingo.txt}

For completeness, the event $<s_0, A>$ is not non-compliant:
\lstinputlisting[language=Prolog]{Figures/AOPL_Language/01_Full_Knowledge/Compliance_Checks/non_compliant.lp}
\lstinputlisting{Figures/AOPL_Language/01_Full_Knowledge/Scripts/01/non_compliant.clingo.txt}

\section{Related Work}

A survey of the literature shows that there have been many other attempts to enable agents to reason over various kinds of policies.
Most involve reasoning over access control policies (e.g. \citet{ferraiolo_role-based_1995,alves_graph-based_2017,barker_logical_2012,sabri_temporal_2016}) and a few utilize ASP as a reasoning tool (e.g. \citet{barker_reasoning_2014,barker_logical_2012}).
Access control policies are more restrictive than the kinds of policies an agent using $\mathcal{AOPL}$ can reason over.
Hence, the work by \citet{liao_extended_2006} is the most relevant for discussion in this thesis.

\subsection{PDC-agent}

\citet{liao_extended_2006} present an extension of the BDI architecture call PDC-agent, which is based off a policy and contract-aware methodology they call BGI-PDC logic\footnotemark.
PDC-agent~\citep{liao_extended_2006} is an event-driven multi-component framework which allows for controlled and coordinated behavior among independent cooperative agents.
\citet{liao_model_2005} use policies to control agent behavior and contracts as a mechanism to coordinate actions between agents.

\footnotetext{
    \citet{liao_extended_2006} do not mention what these acronyms stand for.
}

\begin{definition}
    The PDC-agent architecture for a single agent is defined as a collection of components, which are grouped into three modules.
    Other cooperative agents are defined likewise.
\end{definition}

\begin{definition}
    The \textit{Interpreter} module of the PDC-agent architecture is defined as a 7-tuple of the following components: (Event Treating Engine, Belief Update, Contract Engine, Policy Engine, Goal Maintenance, Plan Engine, Plan Library)~\citep{liao_extended_2006}.
    The role of each component is presented below:

    \begin{itemize}
        \item The \textit{Event Treating Engine} is an event hub that passes messages and performs simple message manipulations~\citep{liao_extended_2006}.
            While some components send events to other components directly, most events are forwarded through the Event Treating Engine.
        \item The \textit{Belief Update} component maintains the agent's belief database on the basis of events and belief-manipulating actions (such as AddBelief or DeleteBelief)~\citep{liao_extended_2006}.
        \item The \textit{Contract Engine} listens for events describing the current state of the environment and emits events to signal when relevant contract clauses dictate the agent perform particular actions~\citep{liao_extended_2006}.
        \item The \textit{Policy Engine} evaluates policies~\citep{liao_extended_2006}.
        \item The \textit{Goal Maintenance} component produces goals~\citep{liao_extended_2006}.
        \item The \textit{Plan Engine} finds plans to meet goals, according to plans in the \textit{Plan Library}~\citep{liao_extended_2006}.
    \end{itemize}
\end{definition}

\begin{definition}
    The \textit{State Module} of the PDC-agent architecture consists of the \textit{Intention Set}, \textit{Goal Set}, and \textit{Beliefs}~\citep{liao_extended_2006}.
    Beliefs constitute an agent's understanding of its environment, the agent's internal states, as well as a representation of contracts and policies~\citep{liao_extended_2006}.
\end{definition}

\begin{definition}
    The \textit{Execution Module} of the PDC-agent architecture consists of the \textit{Execution Engine}, \textit{External actions}, and \textit{Internal actions}~\citep{liao_extended_2006}.
\end{definition}

This architecture, along with the flow of events between its components, is summarized in \cref{fig:pdc_agent_structure}.
An informal representation of the components collective control loop is presented in \cref{fig:pdc_agent_control_loop}\footnotemark.

\footnotetext{
    We have added \cref{fig:pdc_agent_control_loop} based on what \citet{liao_extended_2006} discuss in prose.
}

\citet{peng_extended_2008} extend the PDC-agent architecture to support reasoning over social norms (called NPDC-agent).
However, the discussion of NPDC-agent is not relevant to this section.

\begin{figure}[p]
    \includegraphics[width=\textwidth]{Figures/PDC-agent/Structure_2}
    \centering
    \caption{PDC-agent component interactions}
    \label{fig:pdc_agent_structure}
\end{figure}

\begin{landscape}
    \begin{figure}[p]
        \includegraphics[width=\paperwidth]{Figures/PDC-agent/Control_Loop}
        \centering
        \caption{Simplified control loop of PDC-agent}
        \label{fig:pdc_agent_control_loop}
    \end{figure}
\end{landscape}

A major distinction of the PDC-agent agent architecture is that the PDC-agent architecture supports coordination among multiple agents.
While both the AAA agent architecture and the $\mathcal{AIA}$ agent architecture can allow multiple agents to operate in a shared environment, the AAA and $\mathcal{AIA}$ architectures do not provide any mechanism to coordinate actions between separate agents so that they can work together towards a common goal.

Similar to the $\mathcal{AIA}$ architecture, PDC-agent distinguishes between external actions and internal actions.
Internal actions in the PDC-agent architecture can update beliefs (analogously to $\mathcal{TI}$) but they can also emit events to the Event Treating Engine.
Internal actions available to agents in the PDC-agent architecture are: AddBelief, DeleteBelief, AddDes (which adds desires to the agent), ExTestObj (which executes ``test objectives''), AddPRE (which adds policy reference events), and AddCooperationInfo (which gathers domain-specific information from cooperating agents)~\citep{liao_extended_2006}.

In spite of these similarities, the PDC-agent architecture has another crucial distinction.
the PDC-agent architecture does not reason over a transition system (or, by extension, an action description) and does not use ASP~\citep{liao_extended_2006}.
Instead, knowledge in PDC-agent is formally represented in terms of a Domain Conceptualization Language (DCL)~\citep{ji_gao_sasa5_2005} and a Concept Instance Pattern (CIP)\footnotemark.
While DCL and CIP can represent plans (which are analogous to activities in the $\mathcal{AIA}$ architecture), there is no support for expressing the direct or indirect effects of an action.
This is a disadvantage in comparison to the action-language-based architectures since plans have to be pre-computed and the goals that they accomplish must be annotated according to intuition of the agent's designer.
Since action languages only require a description of the effects of individual actions (and plans consisting of all permutations of actions can be automatically computed), there is significantly less work for a human designer when working with the AAA architecture or the $\mathcal{AIA}$ architecture than the PDC-agent architecture.

\footnotetext{
    For brevity, this thesis will not include the syntax of DCL and CIP nor will it include a discussion on how these languages are used to formally represent each entity in PDC-agent.
}
