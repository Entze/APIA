\chapter{Evaluation}

% Use this chapter to describe the experiments you have run to validate your work.
% Describe the setup, show your data, and discuss the results.
%
% \section{Experimental Design}
%
% \section{Results}
%
% Tables are great for showing results, as seen in Table~\ref{tbl:Sample}.
%
% \begin{table}[ht]
%     \centering
%     \caption{Sample Table with Data}
%     \label{tbl:Sample}
%
%     \begin{tabular}{|l|c|c|}
%     \hline
%     \textbf{Column Title}             & \textbf{Column Title}       & \textbf{Column Title} \\ \hline
%     Row of Data                       & value                       & value                 \\ \hline
%     Row of Data                       & value                       & value                 \\ \hline
%     Row of Data                       & value                       & value                 \\ \hline
%     Row of Data                       & value                       & value                 \\ \hline
%     \end{tabular}
% \end{table}
%
% \section{Discussion}

\section{Runtime Performance Results}

\section{Conciseness}

Since our work on policy fluents and actions operate behind the scenes during the execution of an $\mathcal{APIA}$ agent, the conciseness and expressivity of user-defined encodings for this architecture are determined by the conciseness and expressivity of its underlying user-facing components: Action Language $\mathcal{AL}$ and Language $\mathcal{AOPL}$.

Action Language $\mathcal{AL}$ is a very concise method to represent complex transition systems.
To contrast, manually specifying a transition system would require enumerating all possible states and denoting which actions transition the world from each state to another state.
For example, our simplest example (Example A) has $309$ fluents and $71$ actions.
Though only $13$ are physical fluents and $20$ are physical actions, the user would have to enumerate $2^{13}$ states and then repeat them $2^{(309-13)}$ times for each possible mental and policy fluent value, leading to a grand total of $2^{309}$ states with $|\mathcal{P}(71)|=2^{71}$ compound actions to connect to each state.

In contrast, Example A utilizes $55$$\mathcal{AL}$ rules, only $9$ of which are user-defined (there are $37$ rules in the Theory of Intentions and $9$ in our policy compliance component).

A similar problem exists for $\mathcal{AOPL}$ policies.
Recall that an action can be permitted, not permitted, or not mentioned in an authorization policy as well as obligated to perform, obligated not to perform, or not mentioned in an obligation policy.
Given the non-contradiction axioms, there are $7$ valid combinations of $\mathcal{AOPL}$ policy statements (see \cref{table:apia_non_contradiction}).
Since $\mathcal{AOPL}$ compliance depends on the value of fluents within a state, each of the $2^{309}$ states must be annotated with the $\mathcal{AOPL}$ compliance value of all $71$ elementary actions.

In contrast, Example A utilizes $4$ $\mathcal{AOPL}$ policy statements.

\section{Expressivity}

Action language $\mathcal{AL}$ is also very expressive.
With the addition of a few words, an entire $\mathcal{AL}$ rule can be spoken in English.
For example, a dynamic causal law:
\begin{equation}
\begin{split}
    & move\_through(A, D) \textbf{ causes } in\_room(A, R_{2}) \textbf{ if} \\
    & in\_room(Actor, R_{1}), \\
    & door\_connects(D, R_{2}), \\
    & R_{2} \neq R_{1}
\end{split}
\end{equation}

For each atom, we place the first argument before the predicate name and the following arguments behind it.
For example, move\_through(A, D) becomes ``A move\_through D''.
Then, using the template:

``When actor <first argument of action> performs <action name> <remaining arguments of action>, it causes <first argument of effect> to be <effect name> <remaining arguments of effect> if <first argument of condition> <condition name> < remaining arguments of condition>''.

So, this rule can be read as ``When actor A performs move\_through D, it causes A to be in\_room R if A is in\_room $R_{1}$ and D connects $R_{2}$ and $R_{2}$ is not $R_{1}$.''

Likewise for static laws such as:
\begin{equation}
\begin{split}
    \neg in\_room(A, R_{2}) \textbf{ if } \
        & in\_room(A, R_{1}), \\
        & R_{2} \neq R_{1}
\end{split}
\end{equation}
we can use the following template:

``If <first argument of condition> is <condition name> < remaining arguments of condition>, then <first argument of fluent> is not <fluent name> <remaining arguments of fluent>''.

So, this static law would be read:

``If actor A is in room $R_{1}$ and $R_{1}$ is not $R_{2}$, then actor A is not in room $R_{2}$''.

Executability conditions have a similar reading.

In the case of $\mathcal{AOPL}$ policy statements:
\begin{equation}
    permitted(greet(A, P)) \textbf{ if }
        \neg busy\_working(P)
\end{equation}
is read ``The agent A is permitted to greet P if P is not busy working''

Defeasible statements are prefixed with ``normally''.

\begin{equation}
\begin{split}
    obl(\neg move(A, L)) \textbf{ if } \
        & location\_room(L, R), \\
        & room\_classified(R), \\
        & \neg has\_security\_clearance(A)
\end{split}
\end{equation}

Likewise, obligation statements are read ``The agent A is obligated not to move to L if location L is in room R, R is classified, and A does not have a security clearance.''

Since both $\mathcal{AL}$ and $\mathcal{AOPL}$ statements have straightforward translations to and from English, we believe these to be very readable and writable by other researchers with limited prior experience about these approaches.

\section{Elaboration Tolerance}

\section{Difficulty of Construction}

The difficulty of constructing the $\mathcal{APIA}$ architecture can be evaluated in three different areas: our reconstruction of the $\mathcal{AIA}$ architecture, our implementation of $\mathcal{AOPL}$ compliance, and our integration of $\mathcal{AOPL}$ into the $\mathcal{AIA}$ architecture.

The implementation of $\mathcal{AOPL}$ compliance was very trivial but correctly constructing the logic program of the $\mathcal{AIA}$ architecture was very difficult.
Although copying the $\mathcal{AIA}$ ASP rules was straightforward, identifying transcription errors and typos (both on our end and in Blount's dissertation) was very time consuming.
In traditional programming languages, a programmer usually has a lot of information regarding the symptoms of a problem that allows him to quickly find the root cause.
Stack traces and step-through debuggers are examples.
Even in the worst case (such as a segmentation fault), a programmer can at least assume the approximate location of the error from the timing of the failure in its procedural execution.

None of these apply in an unsatisfiable ASP program.
Unfortunately, solvers such as clingo do not output a partial knowledge base or a statement denoting which rule caused the unsatisfiability.
During our implementation of the $\mathcal{AIA}$ logic program, we resorted to manually commenting out constraints and changing rule heads in order to restore satisfiability.
We then tested hypotheses of the root cause against this information in hopes of guessing correctly.

We used the same method in integrating $\mathcal{AOPL}$ compliance into the $\mathcal{AIA}$ intended action rules.

To assist in this process across control loop iterations, we created a collection of debugging tools and scripts that greatly improved our efficiency.
